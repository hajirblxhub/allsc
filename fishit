local MacLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/bimoraa/Euphoria/refs/heads/main/MacUI/main.luau"))()

local Window = MacLib:Window({
    Title = "Noxius Hub",
    Subtitle = "Noxius Communiy",
    Size = UDim2.fromOffset(580, 420),
    Keybind = Enum.KeyCode.RightShift,
    ShowUserInfo = true,
    DragStyle = 2
})

local tabGroup = Window:TabGroup()

local InfoTab    = tabGroup:Tab({ Name = "Information", Image = "info" })                  
local MainTab    = tabGroup:Tab({ Name = "Main",        Image = "fish" })                 
local TeleportTab = tabGroup:Tab({ Name = "Teleport",   Image = "navigation" })           
local QuestTab   = tabGroup:Tab({ Name = "Quest (soon)",       Image = "scroll" })               
local ShopTab    = tabGroup:Tab({ Name = "Automation",  Image = "zap" })                  
local WebTab     = tabGroup:Tab({ Name = "Webhook",     Image = "link" })                 
local ViewTab    = tabGroup:Tab({ Name = "Settings",        Image = "eye" })                  
local MiscTab    = tabGroup:Tab({ Name = "Misc",        Image = "settings-2" })           

local DiscordSection = InfoTab:Section({
    Name = "Discord",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

DiscordSection:Paragraph({
    Header = "Join Our Discord",
    Body = "Join Us! Dapatkan update terbaru, support, dan komunitas Noxius di sini."
})

DiscordSection:Button({
    Name = "Copy Discord Link",
    Callback = function()
        local link = "https://discord.gg/noxius"
        if setclipboard then
            setclipboard(link)
            Window:Notify({
                Title = "Success",
                Description = "Discord link copied to clipboard!",
                Variant = "success",
                Lifetime = 4
            })
        else
            Window:Notify({
                Title = "Error",
                Description = "Clipboard not supported.",
                Variant = "error"
            })
        end
    end
})

local RodSection = MainTab:Section({
    Name = "Auto Equip Rod",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

local AutoEquipRod = {}
AutoEquipRod.Enabled = false
AutoEquipRod.CheckInterval = 0.5
AutoEquipRod.RodSlot = 1
AutoEquipRod.Connection = nil

local NetFolder = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")

local EquipToolRE = NetFolder:WaitForChild("RE/EquipToolFromHotbar")

local function IsHoldingRod()
    local tool = Character:FindFirstChildOfClass("Tool")
    
    if tool then
        local toolName = tool.Name:lower()
        if toolName:find("rod") or toolName:find("fishing") or toolName:find("pole") then
            return true
        end
    end
    
    return false
end

local function EquipRod()
    if not AutoEquipRod.Enabled then return end
    
    pcall(function()
        EquipToolRE:FireServer(AutoEquipRod.RodSlot)
    end)
end

local function CheckAndEquipRod()
    if not AutoEquipRod.Enabled then return end
    
    if not IsHoldingRod() then
        EquipRod()
    end
end

function AutoEquipRod.Start()
    if AutoEquipRod.Connection then
        AutoEquipRod.Connection:Disconnect()
    end
    
    AutoEquipRod.Enabled = true
    local lastCheck = 0
    
    AutoEquipRod.Connection = RunService.Heartbeat:Connect(function()
        if not AutoEquipRod.Enabled then return end
        
        local currentTime = tick()
        if currentTime - lastCheck >= AutoEquipRod.CheckInterval then
            lastCheck = currentTime
            CheckAndEquipRod()
        end
    end)
end

function AutoEquipRod.Stop()
    AutoEquipRod.Enabled = false
    
    if AutoEquipRod.Connection then
        AutoEquipRod.Connection:Disconnect()
        AutoEquipRod.Connection = nil
    end
end

function AutoEquipRod.IsHoldingRod()
    return IsHoldingRod()
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
    
    if AutoEquipRod.Enabled then
        task.wait(2)
        CheckAndEquipRod()
    end
end)


RodSection:Toggle({
    Name = "Auto Equip Rod",
    Default = false,
    Callback = function(state)
        if state then
            AutoEquipRod.Start()
            Window:Notify({
                Title = "Rod Equip",
                Description = "Auto equip rod nyala",
                Variant = "success"
            })
        else
            AutoEquipRod.Stop()
            Window:Notify({
                Title = "Rod Equip",
                Description = "Auto equip rod mati",
                Variant = "error"
            })
        end
    end
})


local FavoriteSection = MainTab:Section({
    Name = "Auto Favorite",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()

local AutoFavorite = {}

local TIER_MAP = {
    ["Common"] = 1,
    ["Uncommon"] = 2,
    ["Rare"] = 3,
    ["Epic"] = 4,
    ["Legendary"] = 5,
    ["Mythic"] = 6,
    ["SECRET"] = 7
}

local AUTO_FAVORITE_TIERS = {}
local AUTO_FAVORITE_VARIANTS = {}
local AUTO_FAVORITE_ENABLED = false

local activeConnections = {}

local FavoriteEvent = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")
    :WaitForChild("RE/FavoriteItem")

local NotificationEvent = ReplicatedStorage:WaitForChild("Packages")
    :WaitForChild("_Index")
    :WaitForChild("sleitnick_net@0.2.0")
    :WaitForChild("net")
    :WaitForChild("RE/ObtainedNewFishNotification")

local itemsModule = require(ReplicatedStorage:WaitForChild("Items"))

local fishDataCache = {}

local function getFishData(itemId)
    if fishDataCache[itemId] then
        return fishDataCache[itemId]
    end
    
    for _, fish in pairs(itemsModule) do
        if fish.Data and fish.Data.Id == itemId then
            fishDataCache[itemId] = fish
            return fish
        end
    end
    
    return nil
end

function AutoFavorite.GetAllTiers()
    return {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "SECRET"}
end

function AutoFavorite.GetAllVariants()
    return {
        "Galaxy",
        "Corrupt",
        "Gemstone",
        "Fairy Dust",
        "Midnight",
        "Color Burn",
        "Holographic",
        "Lightning",
        "Radioactive",
        "Ghost",
        "Gold",
        "Frozen",
        "1x1x1x1",
        "Stone",
        "Sandy",
        "Noob",
        "Moon Fragment",
        "Festive",
        "Albino",
        "Arctic Frost",
        "Disco"
    }
end

function AutoFavorite.EnableTiers(selectedTiers)
    for _, tierName in ipairs(selectedTiers) do
        local tier = TIER_MAP[tierName]
        if tier then
            AUTO_FAVORITE_TIERS[tier] = true
        end
    end
end

function AutoFavorite.ClearTiers()
    table.clear(AUTO_FAVORITE_TIERS)
end

function AutoFavorite.EnableVariants(selectedVariants)
    for _, variantName in ipairs(selectedVariants) do
        AUTO_FAVORITE_VARIANTS[variantName] = true
    end
end

function AutoFavorite.ClearVariants()
    table.clear(AUTO_FAVORITE_VARIANTS)
end

local function disconnectAll()
    for _, conn in pairs(activeConnections) do
        if conn and conn.Connected then
            conn:Disconnect()
        end
    end
    table.clear(activeConnections)
end

function AutoFavorite.Start()
    disconnectAll()
    
    AUTO_FAVORITE_ENABLED = true
    
    local connection = NotificationEvent.OnClientEvent:Connect(function(itemId, metadata, extraData)
        if not AUTO_FAVORITE_ENABLED then 
            return 
        end
        
        if not extraData or not extraData.InventoryItem then
            return
        end
        
        local inventoryItem = extraData.InventoryItem
        local uuid = inventoryItem.UUID
        
        if not uuid or inventoryItem.Favorited then 
            return 
        end

        local shouldFavorite = false

        if next(AUTO_FAVORITE_TIERS) then
            local fishData = getFishData(itemId)
            if fishData and fishData.Data and fishData.Data.Tier then
                if AUTO_FAVORITE_TIERS[fishData.Data.Tier] then
                    shouldFavorite = true
                end
            end
        end

        if not shouldFavorite and next(AUTO_FAVORITE_VARIANTS) then
            local variantId = metadata and metadata.VariantId
            if variantId and variantId ~= "None" and AUTO_FAVORITE_VARIANTS[variantId] then
                shouldFavorite = true
            end
        end

        if shouldFavorite then
            task.delay(0.35, function()
                pcall(function()
                    FavoriteEvent:FireServer(uuid)
                end)
            end)
        end
    end)
    
    table.insert(activeConnections, connection)
end

function AutoFavorite.Stop()
    AUTO_FAVORITE_ENABLED = false
    disconnectAll()
end

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Character = newCharacter
end)


local tiersList = AutoFavorite.GetAllTiers()
local variantsList = AutoFavorite.GetAllVariants()

FavoriteSection:Toggle({
    Name = "Enable Auto Favorite",
    Default = false,
    Callback = function(state)
        if state then
            AutoFavorite.Start()
            Window:Notify({
                Title = "Auto Favorite",
                Description = "Activated - Will favorite selected tiers/variants",
                Variant = "success",
                Lifetime = 4
            })
        else
            AutoFavorite.Stop()
            Window:Notify({
                Title = "Auto Favorite",
                Description = "Deactivated",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

FavoriteSection:Dropdown({
    Name = "Select Tiers to Favorite",
    Options = tiersList,
    Multi = true,  
    Default = {},
    Callback = function(selected)
        AutoFavorite.ClearTiers()
        AutoFavorite.EnableTiers(selected)
        Window:Notify({
            Title = "Tiers Updated",
            Description = "Favoriting: " .. table.concat(selected, ", ") or "None",
            Variant = "info"
        })
    end
})

FavoriteSection:Dropdown({
    Name = "Select Variants to Favorite",
    Options = variantsList,
    Multi = true,
    Default = {},
    Callback = function(selected)
        AutoFavorite.ClearVariants()
        AutoFavorite.EnableVariants(selected)
        Window:Notify({
            Title = "Variants Updated",
            Description = "Favoriting variants: " .. table.concat(selected, ", ") or "None",
            Variant = "info"
        })
    end
})

FavoriteSection:Button({
    Name = "Clear All Selections",
    Callback = function()
        AutoFavorite.ClearTiers()
        AutoFavorite.ClearVariants()
        Window:Notify({
            Title = "Cleared",
            Description = "All auto favorite selections reset",
            Variant = "info"
        })
    end
})


local TotemSection = MainTab:Section({
    Name = "Auto Totem",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})


local TOTEM_DATA = {
    ["Luck Totem"] = {Id = 1, Duration = 3601},
    ["Mutation Totem"] = {Id = 2, Duration = 3601},
    ["Shiny Totem"] = {Id = 3, Duration = 3601}
}
local TOTEM_NAMES = {"Luck Totem", "Mutation Totem", "Shiny Totem"}
local selectedTotemName = "Luck Totem"


local AUTO_TOTEM_ACTIVE = false
local AUTO_TOTEM_THREAD = nil
local currentTotemExpiry = 0


function GetTotemUUID(name)
    local success, r = pcall(function()
        return require(ReplicatedStorage.Packages.Replion).Client:WaitReplion("Data")
    end)
    if not success then return nil end
    local s, d = pcall(function() return r:GetExpect("Inventory") end)
    if s and d.Totems then 
        for _, i in ipairs(d.Totems) do 
            if tonumber(i.Id) == TOTEM_DATA[name].Id and (i.Count or 1) >= 1 then return i.UUID end 
        end 
    end
    return nil
end


function RunAutoTotemLoop()
    if AUTO_TOTEM_THREAD then task.cancel(AUTO_TOTEM_THREAD) end
    AUTO_TOTEM_THREAD = task.spawn(function()
        while AUTO_TOTEM_ACTIVE do
            local timeLeft = currentTotemExpiry - os.time()
            if timeLeft <= 0 then
                local uuid = GetTotemUUID(selectedTotemName)
                if uuid then
                    
                    pcall(function() Net["RE/SpawnTotem"]:FireServer(uuid) end)
                    currentTotemExpiry = os.time() + TOTEM_DATA[selectedTotemName].Duration                    
                    
                    task.spawn(function() 
                        task.wait(0.5) 
                        for i=1,8 do 
                            task.wait(0.25)
                            pcall(function() 
                                Net["RE/EquipToolFromHotbar"]:FireServer(1) 
                            end)
                        end
                        
                        print("[Auto Totem] Rod re-equipped after spawning " .. selectedTotemName)
                    end)
                end
            end
            task.wait(1)
        end
    end)
end

TotemSection:Dropdown({
    Name = "Select Totem Type",
    Options = {"Luck Totem", "Mutation Totem", "Shiny Totem"},
    Default = selectedTotemName,
    Callback = function(n) 
        selectedTotemName = n
        currentTotemExpiry = 0 
        Window:Notify({
            Title = "Totem Updated",
            Description = "Selected: " .. n,
            Variant = "info",
            Lifetime = 3
        })
    end 
})

TotemSection:Toggle({
    Name = "Enable Auto Totem (Single)",
    Default = false,
    Callback = function(s) 
        AUTO_TOTEM_ACTIVE = s
        if s then 
            RunAutoTotemLoop() 
            Window:Notify({
                Title = "Auto Totem Single",
                Description = "Activated - Waiting for expiry",
                Variant = "success",
                Lifetime = 4
            })
        else 
            if AUTO_TOTEM_THREAD then task.cancel(AUTO_TOTEM_THREAD) end 
            Window:Notify({
                Title = "Auto Totem Single",
                Description = "Deactivated",
                Variant = "error",
                Lifetime = 3
            })
        end 
    end 
})


local AUTO_3_TOTEM_ACTIVE = false
local AUTO_3_TOTEM_THREAD = nil

local TOTEM_MIX_ORDER = {"Shiny Totem", "Luck Totem", "Mutation Totem"}

local REF_CENTER = Vector3.new(93.932, 9.532, 2684.134)
local REF_SPOTS = {
    Vector3.new(45.0468979, 13.5, 2730.19067),   -- 1
    Vector3.new(145.644608, 13.5, 2721.90747),   -- 2
    Vector3.new(84.6406631, 14.2, 2636.05786),   -- 3
}

local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Net = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net

local function GetRoot()
    local player = game:GetService("Players").LocalPlayer
    local char = player.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
end

-- Helper: Tween Character to Target CFrame
local function TweenTo(targetCFrame, duration)
    local root = GetRoot()
    if not root then return end
    
    -- Ensure Anchored for Tween
    root.Anchored = true
    
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(root, tweenInfo, {CFrame = targetCFrame})
    tween:Play()
    tween.Completed:Wait()
    -- Keep anchored until platform interaction
end

-- Helper: Create Temporary Platform
local function CreatePlatform(position)
    local plat = Instance.new("Part")
    plat.Name = "TotemPlatform"
    plat.Size = Vector3.new(10, 1, 10)
    plat.Position = position - Vector3.new(0, 3.5, 0) -- Slightly below player
    plat.Anchored = true
    plat.CanCollide = true
    plat.Transparency = 0.5
    plat.Color = Color3.fromRGB(0, 255, 255)
    plat.Material = Enum.Material.Neon
    plat.Parent = workspace
    return plat
end

local function Run3TotemLoop()
    if AUTO_3_TOTEM_THREAD then task.cancel(AUTO_3_TOTEM_THREAD) end
    
    AUTO_3_TOTEM_THREAD = task.spawn(function()
        AUTO_3_TOTEM_ACTIVE = true
        
        local player = game:GetService("Players").LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()
        local root = GetRoot()
        
        if not root then 
            AUTO_3_TOTEM_ACTIVE = false
            return 
        end
        
        local startCFrame = root.CFrame
        Window:Notify({ Title = "Started", Description = "3 Totem Mix (Tween Mode)", Lifetime = 4 })
        
        -- Equip Oxygen Tank (Optional safety)
        local RF_EquipOxygenTank = Net["RF/EquipOxygenTank"]
        if RF_EquipOxygenTank then pcall(function() RF_EquipOxygenTank:InvokeServer(105) end) end

        -- PRIMARY LOOP: Runs indefinitely until toggled off
        while AUTO_3_TOTEM_ACTIVE do
            -- Loop through spots
            for i, refSpot in ipairs(REF_SPOTS) do
                if not AUTO_3_TOTEM_ACTIVE then break end
                
                local targetTotemName = TOTEM_MIX_ORDER[i]
                -- Calculate Adjust position relative to center
                local relativePos = refSpot - REF_CENTER
                local targetPos = startCFrame.Position + relativePos
                
                local targetCFrame = CFrame.new(targetPos)
                
                -- 1. Tween to Location
                local dist = (root.Position - targetPos).Magnitude
                local travelTime = math.max(1.5, dist / 60) -- Speed calc
                
                TweenTo(targetCFrame, travelTime)
                
                -- 2. Create Platform & Stand
                local platform = CreatePlatform(targetPos)
                root.Anchored = false -- Allow standing on platform
                
                task.wait(0.5) -- Stabilize
                
                -- 3. Spawn & Equip Totem
                local uuid = GetTotemUUID(targetTotemName)
                if uuid then
                    pcall(function() Net["RE/SpawnTotem"]:FireServer(uuid) end)
                    
                    -- Equip Loop
                    task.spawn(function() 
                        for k=1,5 do -- More attempts
                            pcall(function() Net["RE/EquipToolFromHotbar"]:FireServer(1) end)
                            task.wait(0.2) 
                        end 
                    end)
                    Window:Notify({ Title = "Spawned", Description = targetTotemName, Lifetime = 2 })
                else
                    Window:Notify({ Title = "Skip", Description = "No " .. targetTotemName .. " available", Lifetime = 2 })
                end
                
                task.wait(3) -- Wait for usage/interaction
                
                -- 4. Cleanup Platform & Prepare for next
                if platform then platform:Destroy() end
                root.Anchored = true -- Prepare for next tween
            end
            
            -- Return to Start Position
            if AUTO_3_TOTEM_ACTIVE then
                TweenTo(startCFrame, 2)
                root.Anchored = false
                Window:Notify({ Title = "Cycle Done", Description = "Waiting 1 Hour...", Lifetime = 10 })
            end
            
            -- Wait 1 Hour (with breakdown for cancellation)
            for waitTime = 3600, 1, -1 do
                if not AUTO_3_TOTEM_ACTIVE then break end
                task.wait(1)
            end
        end
        
        -- Unequip Oxygen (When manually stopped)
        local RF_UnequipOxygenTank = Net["RF/UnequipOxygenTank"]
        if RF_UnequipOxygenTank then pcall(function() RF_UnequipOxygenTank:InvokeServer() end) end
    end)
end

-- UI for Mix 3 Totem
TotemSection:Toggle({
    Name = "Auto Spawn 3 Totem Mix",
    Default = false,
    Callback = function(s)
        AUTO_3_TOTEM_ACTIVE = s
        if s then
            Run3TotemLoop()
            Window:Notify({
                Title = "Auto 3 Totem Mix",
                Description = "Activated - Shiny -> Luck -> Mutation cycle",
                Variant = "success",
                Lifetime = 4
            })
        else
            AUTO_3_TOTEM_ACTIVE = false
            if AUTO_3_TOTEM_THREAD then task.cancel(AUTO_3_TOTEM_THREAD) end
            
            -- Cleanup if stopped mid-way
            local root = GetRoot()
            if root then root.Anchored = false end
            for _, v in ipairs(workspace:GetChildren()) do
                if v.Name == "TotemPlatform" then v:Destroy() end
            end
            
            Window:Notify({
                Title = "Stopped",
                Description = "Mix 3 Totem cancelled",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})


-- AUTO BUY TOTEM SECTION IN MAIN TAB
local BuyTotemSection = MainTab:Section({
    Name = "Auto Buy Totem",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- Paste your code exactly here (no changes to logic)
local TOTEM_DATA = {
    ["Luck Totem"] = {Id = 5, Duration = 3601},
    ["Mutation Totem"] = {Id = 8, Duration = 3601},
    ["Shiny Totem"] = {Id = 7, Duration = 3601}
}

local TotemMarketIds = {
	["Luck Totem"] = 5,
	["Shiny Totem"] = 7,
	["Mutation Totem"] = 8
}

local TotemPrices = {
	["Luck Totem"] = 650000,
	["Shiny Totem"] = 400000,
	["Mutation Totem"] = 800000
}

_G.AutoBuyTotem = false
_G.SelectedBuyTotem = "Luck Totem"
_G.BuyTotemLimit = 10
local purchaseCount = 0

-- Dropdown untuk pilih totem
BuyTotemSection:Dropdown({
    Name = "Select Totem to Buy",
    Options = {"Luck Totem", "Shiny Totem", "Mutation Totem"},
    Default = "Luck Totem",
    Callback = function(selected)
        _G.SelectedBuyTotem = selected
        Window:Notify({
            Title = "Totem Selected",
            Description = "Buying: " .. selected .. " (" .. TotemPrices[selected] .. " coins)",
            Variant = "info",
            Lifetime = 3
        })
    end
})

-- Input untuk batas pembelian
BuyTotemSection:Input({
    Name = "Purchase Limit",
    Default = "10",
    Numeric = true,
    Callback = function(text)
        local value = tonumber(text)
        if value and value > 0 then
            _G.BuyTotemLimit = value
            Window:Notify({
                Title = "Limit Updated",
                Description = "Max purchases set to: " .. value,
                Variant = "info",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Invalid Input",
                Description = "Enter a valid number > 0",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

-- Toggle Auto Buy Totem
BuyTotemSection:Toggle({
    Name = "Enable Auto Buy Totem",
    Default = false,
    Callback = function(value)
        _G.AutoBuyTotem = value
        
        if value then
            purchaseCount = 0 -- Reset counter
            
            Window:Notify({
                Title = "Auto Buy Enabled",
                Description = "Buying: " .. _G.SelectedBuyTotem .. " | Limit: " .. _G.BuyTotemLimit,
                Variant = "success",
                Lifetime = 4
            })
            
            -- Auto buy loop
            task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local PurchaseRemote = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseMarketItem"]
                
                -- Inventory IDs (different from Market IDs)
                local TotemInventoryIds = {
                    ["Luck Totem"] = 1,
                    ["Mutation Totem"] = 2,
                    ["Shiny Totem"] = 3
                }

                -- Function to check inventory count
                local function GetTotemCount(totemName)
                    local success, result = pcall(function()
                        local Client = require(ReplicatedStorage.Packages.Replion).Client
                        local dataStore = Client:WaitReplion("Data")
                        local inventory = dataStore:GetExpect("Inventory")
                        
                        -- Get correct Inventory ID
                        local inventoryId = TotemInventoryIds[totemName]
                        
                        if inventory and inventory.Totems then
                            local totalCount = 0
                            for _, item in ipairs(inventory.Totems) do
                                -- Check by Inventory ID
                                if tonumber(item.Id) == inventoryId then
                                    totalCount = totalCount + (item.Count or 1)
                                end
                            end
                            return totalCount
                        end
                        return 0
                    end)
                    
                    if not success then
                        warn("[Auto Buy] GetTotemCount error:", result)
                        return 0
                    end
                    
                    return result or 0
                end
                
                while _G.AutoBuyTotem and purchaseCount < _G.BuyTotemLimit do
                    local totemId = TotemMarketIds[_G.SelectedBuyTotem]
                    local beforeCount = GetTotemCount(_G.SelectedBuyTotem)
                    
                    -- Try to purchase
                    local success, result = pcall(function()
                        return PurchaseRemote:InvokeServer(totemId)
                    end)
                    
                    if success then
                        if result then
                            -- Wait a bit for inventory to update
                            task.wait(0.5)
                            
                            -- Verify purchase by checking inventory
                            local afterCount = GetTotemCount(_G.SelectedBuyTotem)
                            
                            if afterCount > beforeCount then
                                purchaseCount = purchaseCount + 1
                                print("[Auto Buy] ✓ Purchased:", _G.SelectedBuyTotem, "ID:", totemId, "Count:", purchaseCount .. "/" .. _G.BuyTotemLimit)
                                print("[Auto Buy] Inventory:", afterCount, "totems")
                                Window:Notify({
                                    Title = "Purchased",
                                    Description = _G.SelectedBuyTotem .. " bought! (" .. purchaseCount .. "/" .. _G.BuyTotemLimit .. ")",
                                    Variant = "success",
                                    Lifetime = 3
                                })
                            else
                                warn("[Auto Buy] ⚠️ Purchase response OK but inventory not updated")
                            end
                        else
                            warn("[Auto Buy] ✗ Purchase failed (not enough coins or error)")
                            Window:Notify({
                                Title = "Purchase Failed",
                                Description = "Not enough coins or server error",
                                Variant = "error",
                                Lifetime = 3
                            })
                        end
                    else
                        warn("[Auto Buy] Error:", result)
                        Window:Notify({
                            Title = "Error",
                            Description = "Purchase remote failed",
                            Variant = "error",
                            Lifetime = 3
                        })
                    end
                    
                    -- Wait before next purchase attempt
                    task.wait(1)
                end
                
                -- Auto disable when limit reached
                if purchaseCount >= _G.BuyTotemLimit then
                    _G.AutoBuyTotem = false
                    Window:Notify({
                        Title = "Auto Buy Completed",
                        Description = "Purchased " .. purchaseCount .. " totems! Auto buy disabled.",
                        Variant = "success",
                        Lifetime = 5
                    })
                end
            end)
        else
            Window:Notify({
                Title = "Auto Buy Disabled",
                Description = "Stopped auto buying totems\nPurchased: " .. purchaseCount .. " totems",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

BuyTotemSection:Button({
    Name = "Open Merchant GUI",
    Callback = function()
        local merchantGui = game:GetService("Players").LocalPlayer.PlayerGui:FindFirstChild("Merchant")
        if merchantGui then
            merchantGui.Enabled = not merchantGui.Enabled
            Window:Notify({
                Title = "Merchant GUI",
                Description = merchantGui.Enabled and "Opened" or "Closed",
                Variant = merchantGui.Enabled and "success" or "info",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Error",
                Description = "Merchant GUI not found in PlayerGui",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})


-- FPS BOOSTER SECTION IN MAIN TAB
local FPSSection = MainTab:Section({
    Name = "FPS Booster",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- MODULE FPS BOOSTER (paste persis dari code lu)
local FPSBooster = {}
FPSBooster.Enabled = false

local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local Terrain = workspace:FindFirstChildOfClass("Terrain")

-- Storage untuk restore
local originalStates = {
    reflectance = {},
    transparency = {},
    lighting = {},
    effects = {},
    waterProperties = {}
}

-- Connection untuk new objects
local newObjectConnection = nil

-- Fungsi untuk optimize single object
function optimizeObject(obj)
    if not FPSBooster.Enabled then return end
    
    pcall(function()
        if obj:IsA("BasePart") then
            if not originalStates.reflectance[obj] then
                originalStates.reflectance[obj] = obj.Reflectance
            end
            
            obj.Reflectance = 0
            obj.CastShadow = false
        end
        
        if obj:IsA("Decal") or obj:IsA("Texture") then
            if not originalStates.transparency[obj] then
                originalStates.transparency[obj] = obj.Transparency
            end
            obj.Transparency = 1
        end
        
        if obj:IsA("SurfaceAppearance") then
            obj:Destroy()
        end
        
        if obj:IsA("ParticleEmitter") then
            obj.Enabled = false
        end
        
        if obj:IsA("Trail") then
            obj.Enabled = false
        end
        
        if obj:IsA("Beam") then
            obj.Enabled = false
        end
        
        if obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
            obj.Enabled = false
        end
    end)
end

-- Fungsi untuk restore single object
function restoreObject(obj)
    pcall(function()
        if obj:IsA("BasePart") then
            if originalStates.reflectance[obj] then
                obj.Reflectance = originalStates.reflectance[obj]
                obj.CastShadow = true
            end
        end
        
        if obj:IsA("Decal") or obj:IsA("Texture") then
            if originalStates.transparency[obj] then
                obj.Transparency = originalStates.transparency[obj]
            end
        end
        
        if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") then
            obj.Enabled = true
        end
        
        if obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
            obj.Enabled = true
        end
    end)
end

function FPSBooster.Enable()
    if FPSBooster.Enabled then
        return false, "Already enabled"
    end
    
    FPSBooster.Enabled = true
    
    for _, obj in ipairs(workspace:GetDescendants()) do
        optimizeObject(obj)
    end
    
    if Terrain then
        pcall(function()
            originalStates.waterProperties = {
                WaterReflectance = Terrain.WaterReflectance,
                WaterWaveSize = Terrain.WaterWaveSize,
                WaterWaveSpeed = Terrain.WaterWaveSpeed
            }
            
            Terrain.WaterWaveSize = 0
            Terrain.WaterWaveSpeed = 0
            Terrain.WaterReflectance = 0
        end)
    end
    
    originalStates.lighting = {
        GlobalShadows = Lighting.GlobalShadows,
        FogEnd = Lighting.FogEnd,
        FogStart = Lighting.FogStart
    }
    
    Lighting.GlobalShadows = false
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000
    
    for _, effect in ipairs(Lighting:GetChildren()) do
        if effect:IsA("PostEffect") then
            originalStates.effects[effect] = effect.Enabled
            effect.Enabled = false
        end
    end
    
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    
    newObjectConnection = workspace.DescendantAdded:Connect(function(obj)
        if FPSBooster.Enabled then
            task.wait(0.1)
            optimizeObject(obj)
        end
    end)
    
    return true, "FPS Booster enabled"
end

function FPSBooster.Disable()
    if not FPSBooster.Enabled then
        return false, "Already disabled"
    end
    
    FPSBooster.Enabled = false
    
    for _, obj in ipairs(workspace:GetDescendants()) do
        restoreObject(obj)
    end
    
    if Terrain and originalStates.waterProperties then
        pcall(function()
            Terrain.WaterReflectance = originalStates.waterProperties.WaterReflectance
            Terrain.WaterWaveSize = originalStates.waterProperties.WaterWaveSize
            Terrain.WaterWaveSpeed = originalStates.waterProperties.WaterWaveSpeed
        end)
    end
    
    if originalStates.lighting.GlobalShadows ~= nil then
        Lighting.GlobalShadows = originalStates.lighting.GlobalShadows
        Lighting.FogEnd = originalStates.lighting.FogEnd
        Lighting.FogStart = originalStates.lighting.FogStart
    end
    
    for effect, state in pairs(originalStates.effects) do
        if effect and effect.Parent then
            effect.Enabled = state
        end
    end
    
    settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
    
    if newObjectConnection then
        newObjectConnection:Disconnect()
        newObjectConnection = nil
    end
    
    originalStates = {
        reflectance = {},
        transparency = {},
        lighting = {},
        effects = {},
        waterProperties = {}
    }
    
    return true, "FPS Booster disabled"
end

function FPSBooster.IsEnabled()
    return FPSBooster.Enabled
end

-- Toggle UI
FPSSection:Toggle({
    Name = "Enable FPS Booster",
    Default = false,
    Callback = function(value)
        if value then
            local success, msg = FPSBooster.Enable()
            if success then
                Window:Notify({
                    Title = "FPS Booster",
                    Description = "Enabled - Shadows, reflections, particles & effects removed",
                    Variant = "success",
                    Lifetime = 4
                })
            else
                Window:Notify({
                    Title = "FPS Booster",
                    Description = msg or "Failed to enable",
                    Variant = "error",
                    Lifetime = 3
                })
            end
        else
            local success, msg = FPSBooster.Disable()
            if success then
                Window:Notify({
                    Title = "FPS Booster",
                    Description = "Disabled - Graphics restored to normal",
                    Variant = "info",
                    Lifetime = 3
                })
            else
                Window:Notify({
                    Title = "FPS Booster",
                    Description = msg or "Already disabled",
                    Variant = "error",
                    Lifetime = 3
                })
            end
        end
    end
})


-- FAST REEL V1 SECTION IN MAIN TAB (renamed to avoid conflict)
local FastReelSection = MainTab:Section({
    Name = "Fast Reel V1",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- Paste your code exactly here (no changes to logic, only renamed section)
local Pahaji = {
    UB = {
        AktifBae = false,
        Settingan = {
            CompleteHaji = 0.9,
            CancelHaji = 0.6
        },
        RemoteTv = {},
        Statstik = {
            CountCast = 0,
            TimeStart = 0
        },
        _minigameListener = nil
    },
    isMinig = false,
    isFarming = false
}

local skipaja = false
local blatantFishCycleCount = 0

local function safeFire(func)
    task.spawn(function()
        pcall(func)
    end)
end

-- ub spam
local function ub_loop()
    while Pahaji.UB.AktifBae do
        if Pahaji.isMinig then
            task.wait(3)
        else
            local currentTime = tick()
            safeFire(function()
                Pahaji.UB.RemoteTv.CancelFishingInputs:InvokeServer()
            end)
            task.wait(Pahaji.UB.Settingan.CancelHaji)
            safeFire(function()
                Pahaji.UB.RemoteTv.equip:FireServer(1)
                Pahaji.UB.RemoteTv.ChargeFishingRod:InvokeServer({[1] = currentTime})
            end)
            safeFire(function()
                task.wait(0.000001)
                Pahaji.UB.RemoteTv.RequestMinigame:InvokeServer(1, 0, currentTime)
            end)
            task.wait(Pahaji.UB.Settingan.CompleteHaji)
            if not skipaja then
                blatantFishCycleCount = blatantFishCycleCount + 1
                safeFire(function()
                    Pahaji.UB.RemoteTv.FishingCompleted:InvokeServer()
                end)
            end
        end
    end
end

-- Initialize network events
function UB_init()
    local success, netFolder = pcall(function()
        return ReplicatedStorage:WaitForChild("Packages", 10)
            :WaitForChild("_Index", 10)
            :WaitForChild("sleitnick_net@0.2.0", 10)
            :WaitForChild("net", 10)
    end)
    if not success or not netFolder then
        print('no netfolder')
        return false
    end
    Pahaji.UB.RemoteTv.ChargeFishingRod = netFolder:FindFirstChild("RF/ChargeFishingRod")
    Pahaji.UB.RemoteTv.RequestMinigame = netFolder:FindFirstChild("RF/RequestFishingMinigameStarted")
    Pahaji.UB.RemoteTv.CancelFishingInputs = netFolder:FindFirstChild("RF/CancelFishingInputs")
    Pahaji.UB.RemoteTv.UpdateAutoFishingState = netFolder:FindFirstChild("RF/UpdateAutoFishingState")
    Pahaji.UB.RemoteTv.FishingCompleted = netFolder:FindFirstChild("RF/CatchFishCompleted")
    Pahaji.UB.RemoteTv.MinigameChanged = netFolder:FindFirstChild("RE/FishingMinigameChanged")
    Pahaji.UB.RemoteTv.equip = netFolder:FindFirstChild("RE/EquipToolFromHotbar")
    if Pahaji.UB._minigameListener then
        Pahaji.UB._minigameListener:Disconnect()
        Pahaji.UB._minigameListener = nil
    end
    if Pahaji.UB.RemoteTv.MinigameChanged then
        print('minigame listener')
        Pahaji.UB._minigameListener = Pahaji.UB.RemoteTv.MinigameChanged.OnClientEvent:Connect(function(state)
            if not Pahaji.UB.AktifBae then return end
            task.spawn(function()
                task.wait(Pahaji.UB.Settingan.CompleteHaji)
                if not skipaja then
                    safeFire(function()
                        Pahaji.UB.RemoteTv.FishingCompleted:InvokeServer()
                    end)
                end
            end)
        end)
    end
    return true
end

-- Start function
function UB_start()
    if Pahaji.UB.AktifBae then
        print('ub not AktifBae')
        return
    end
    if not UB_init() then
        print('not ub init')
        return
    end
    Pahaji.UB.AktifBae = true
    Pahaji.UB.Statstik.CountCast = 0
    Pahaji.UB.Statstik.TimeStart = tick()
    print('starting loop')
    task.spawn(ub_loop)
end

-- Stop function
function UB_stop()
    if not Pahaji.UB.AktifBae then
        return
    end
    Pahaji.UB.AktifBae = false
    safeFire(function()
        if Pahaji.UB.RemoteTv.UpdateAutoFishingState then
            Pahaji.UB.RemoteTv.UpdateAutoFishingState:InvokeServer(true)
        end
    end)
    task.wait(0.2)
    safeFire(function()
        if Pahaji.UB.RemoteTv.CancelFishingInputs then
            Pahaji.UB.RemoteTv.CancelFishingInputs:InvokeServer()
        end
    end)
    local runtime = tick() - Pahaji.UB.Statstik.TimeStart
end

-- Fungsi toggle (dipanggil dari UI)
local function onToggleUB(value)
    if value then
        if Pahaji.UB.RemoteTv.equip then
            Pahaji.UB.RemoteTv.equip:FireServer(1)
        end
        UB_start()
    else
        UB_stop()
    end
end

FastReelSection:Toggle({
    Name = "Enable Fast Reel V1",
    Default = false,
    Callback = function(state)
        onToggleUB(state)
        Window:Notify({
            Title = "Fast Reel V1",
            Description = state and "Activated - Blatant auto fishing" or "Deactivated",
            Variant = state and "success" or "error",
            Lifetime = 3
        })
    end
})

FastReelSection:Input({
    Name = "Delay Bait (Cancel)",
    Default = "0.6",
    Numeric = true,
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            Pahaji.UB.Settingan.CancelHaji = n
            Window:Notify({
                Title = "Delay Updated",
                Description = "Cancel delay set to: " .. n .. " seconds",
                Variant = "info",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Invalid Input",
                Description = "Enter a valid number > 0",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

FastReelSection:Input({
    Name = "Delay Reel (Complete)",
    Default = "0.9",
    Numeric = true,
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            Pahaji.UB.Settingan.CompleteHaji = n
            Window:Notify({
                Title = "Delay Updated",
                Description = "Complete delay set to: " .. n .. " seconds",
                Variant = "info",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Invalid Input",
                Description = "Enter a valid number > 0",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})


local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

-- REMOTES
local net = ReplicatedStorage.Packages["_Index"]["sleitnick_net@0.2.0"].net
local equipTool     = net["RE/EquipToolFromHotbar"]
local chargeRod     = net["RF/ChargeFishingRod"]
local startFish     = net["RF/RequestFishingMinigameStarted"]
local completeFish  = net["RF/CatchFishCompleted"]
local Hans = {
    Burst = 2,
    completeDelay = 0.02
}

local POWER = -0.0

local Engine = {
    Running = false,
    Worker = nil
}

local function now()
    return workspace:GetServerTimeNow()
end

local function startEngine()
    if Engine.Worker then return end

    Engine.Worker = task.spawn(function()
        local cycle = 0

        while true do
            if Engine.Running then
                cycle += 1
                task.spawn(function()
                    pcall(function()
                        chargeRod:InvokeServer(now())
                    end)
                    pcall(function()
                        startFish:InvokeServer(-9, POWER, now())
                    end)
                end)
                
                for i = 1, 3 do
                  pcall(function()
                    completeFish:InvokeServer(now())
                  end)
                end
            else
                task.wait(Hans.completeDelay) -- pakai field yang sama
            end
        end
    end)
end

local FastReelPler = MainTab:Section({
    Name = "Fast Reel V2",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

FastReelPler:Toggle({
    Name = "Enable Fast Reel V2",
    Default = false,
    Callback = function(state)
        Engine.Running = state
        if Engine.Running then
            startEngine()
        end
    end
})

FastReelPler:Input({
    Name = "Delay Reel (Complete)",
    Default = tostring(Hans.completeDelay),
    Numeric = true,
    Callback = function(v)
        local n = tonumber(v)
        if n and n > 0 then
            Hans.completeDelay = n -- konsisten
            Window:Notify({
                Title = "Delay Updated",
                Description = "Complete delay set to: " .. n .. " seconds",
                Variant = "info",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Invalid Input",
                Description = "Enter a valid number > 0",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

local MiscFeaturesSection = MiscTab:Section({
    Name = "Misc",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- DISABLE 3D RENDERING (FPS BOOST REAL)
local renderEnabled = true
local function setRender(state)
    renderEnabled = state
    game:GetService("RunService"):Set3dRenderingEnabled(state)
    print("[Disable3D]", state and "3D Rendering ENABLED" or "3D Rendering DISABLED")
end

-- Keep-alive loop
task.spawn(function()
    while task.wait(3) do
        game:GetService("RunService"):Set3dRenderingEnabled(renderEnabled)
    end
end)

-- Re-apply on respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    game:GetService("RunService"):Set3dRenderingEnabled(renderEnabled)
    print("[Disable3D] Re-applied after respawn")
end)

MiscFeaturesSection:Toggle({
    Name = "Disable 3D Rendering",
    Default = false,
    Callback = function(state)
        setRender(not state)  -- state true = disable rendering
        Window:Notify({
            Title = "3D Rendering",
            Description = state and "Disabled (FPS Boost)" or "Enabled (Normal)",
            Variant = state and "success" or "info",
            Lifetime = 3
        })
    end
})

-- FREEZE CHARACTER
local freezeConnection
local originalCFrame

MiscFeaturesSection:Toggle({
    Name = "Freeze Character",
    Default = false,
    Callback = function(state)
        _G.FreezeCharacter = state
        if state then
            local character = game.Players.LocalPlayer.Character
            if character then
                local root = character:FindFirstChild("HumanoidRootPart")
                if root then
                    originalCFrame = root.CFrame
                    freezeConnection = game:GetService("RunService").Heartbeat:Connect(function()
                        if _G.FreezeCharacter and root then
                            root.CFrame = originalCFrame
                        end
                    end)
                    Window:Notify({
                        Title = "Freeze Character",
                        Description = "Character frozen in place",
                        Variant = "success",
                        Lifetime = 3
                    })
                end
            end
        else
            if freezeConnection then
                freezeConnection:Disconnect()
                freezeConnection = nil
            end
            Window:Notify({
                Title = "Freeze Character",
                Description = "Character unfrozen",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})

-- DISABLE FISH CAUGHT NOTIF
local disableNotifs = false

MiscFeaturesSection:Toggle({
    Name = "Disable Fish Caught Notif",
    Default = false,
    Callback = function(state)
        disableNotifs = state
        
        local PlayerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
        
        if state then
            -- Hapus yang sudah ada
            local smallNotif = PlayerGui:FindFirstChild("Small Notification")
            if smallNotif then smallNotif:Destroy() end
            
            -- Auto-hapus setiap kali spawn baru
            PlayerGui.ChildAdded:Connect(function(child)
                if disableNotifs and (child.Name == "Small Notification" or 
                   (child:FindFirstChild("Display") and child:FindFirstChildWhichIsA("Frame"))) then
                    task.spawn(function()
                        task.wait()
                        if child and child.Parent then
                            child:Destroy()
                        end
                    end)
                end
            end)
            
            Window:Notify({
                Title = "Fish Caught Notif",
                Description = "Disabled - No more notifications",
                Variant = "success",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Fish Caught Notif",
                Description = "Enabled - Notifications restored",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})

-- DISABLE CHAR EFFECT
local disableCharFx = false

MiscFeaturesSection:Toggle({
    Name = "Disable Char Effect",
    Default = false,
    Callback = function(state)
        disableCharFx = state
        if state then
            local effectEvents = {
                Net["RE/PlayFishingEffect"]
            }

            for _, ev in ipairs(effectEvents) do
                if ev and ev.OnClientEvent then
                    for _, conn in ipairs(getconnections(ev.OnClientEvent)) do
                        conn:Disconnect()
                    end
                    ev.OnClientEvent:Connect(function() end)
                end
            end

            if FishingController then
                if not _fxBackup then
                    _fxBackup = {
                        PlayFishingEffect = FishingController.PlayFishingEffect,
                        ReplicateCutscene = FishingController.ReplicateCutscene
                    }
                end
                FishingController.PlayFishingEffect = function() end
                FishingController.ReplicateCutscene = function() end
            end
            
            Window:Notify({
                Title = "Char Effect",
                Description = "Disabled - Character effects removed",
                Variant = "success",
                Lifetime = 3
            })
        else
            if _fxBackup then
                for k, v in pairs(_fxBackup) do
                    FishingController[k] = v
                end
            end
            Window:Notify({
                Title = "Char Effect",
                Description = "Enabled - Character effects restored",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})

-- DISABLE FISHING EFFECT
local delEffects = false

MiscFeaturesSection:Toggle({
    Name = "Disable Fishing Effect",
    Default = false,
    Callback = function(state)
        delEffects = state
        
        if state then
            spawn(function()
                while delEffects do
                    local cosmetic = workspace:FindFirstChild("CosmeticFolder")
                    if cosmetic then
                        for _, child in ipairs(cosmetic:GetChildren()) do
                            local isExactPart   = child.Name == "Part"
                            local isPureNumber  = string.match(child.Name, "^%d+$")
                            local isModel       = child:IsA("Model")

                            if not (isExactPart or isPureNumber or isModel) then
                                child:Destroy()
                            end
                        end
                    end
                    task.wait(0.1)
                end
            end)
            
            if not _G.EffectsConnection then
                local cosmetic = workspace:WaitForChild("CosmeticFolder", 5)
                if cosmetic then
                    _G.EffectsConnection = cosmetic.ChildAdded:Connect(function(child)
                        if delEffects then
                            task.wait()
                            local isExactPart  = child.Name == "Part"
                            local isPureNumber = string.match(child.Name, "^%d+$")
                            local isModel      = child:IsA("Model")

                            if not (isExactPart or isPureNumber or isModel) then
                                child:Destroy()
                            end
                        end
                    end)
                end
            end
            
            Window:Notify({
                Title = "Fishing Effect",
                Description = "Disabled - Fishing cosmetics removed",
                Variant = "success",
                Lifetime = 3
            })
        else
            if _G.EffectsConnection then
                _G.EffectsConnection:Disconnect()
                _G.EffectsConnection = nil
            end
            Window:Notify({
                Title = "Fishing Effect",
                Description = "Enabled - Fishing cosmetics restored",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})

-- HIDE ROD ON HAND
local hideRod = false

MiscFeaturesSection:Toggle({
    Name = "Hide Rod On Hand",
    Default = false,
    Callback = function(state)
        hideRod = state
        if state then
            spawn(LPH_NO_VIRTUALIZE(function()
                while hideRod do
                    for _, char in ipairs(workspace.Characters:GetChildren()) do
                        local toolFolder = char:FindFirstChild("!!!EQUIPPED_TOOL!!!")
                        if toolFolder then
                            toolFolder:Destroy()
                        end
                    end
                    task.wait(1)
                end
            end))
            Window:Notify({
                Title = "Hide Rod",
                Description = "Activated - Rod hidden on hand",
                Variant = "success",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Hide Rod",
                Description = "Deactivated - Rod visible again",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})


-- ISLAND TELEPORT SECTION IN TELEPORT TAB
local IslandSection = TeleportTab:Section({
    Name = "Island Teleport",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

local IslandLocations = {
    ["Ancient Ruins"] = Vector3.new(6009, -585, 4691),
    ["Ancient Jungle"] = Vector3.new(1518, 1, -186),
    ["Coral Refs"] = Vector3.new(-2855, 47, 1996),
    ["Crater Island"] = Vector3.new(997, 1, 5012),
    ["Enchant Room"] = Vector3.new(3221, -1303, 1406),
    ["Enchant Room 2"] = Vector3.new(1480, 126, -585),
    ["Esoteric Island"] = Vector3.new(1990, 5, 1398),
    ["Fisherman Island"] = Vector3.new(-175, 3, 2772),
    ["Kohana Volcano"] = Vector3.new(-545.302429, 17.1266193, 118.870537),
    ["Kohana"] = Vector3.new(-603, 3, 719),
    ["Kohana Spot 1"] = Vector3.new(-703.661194, 17.2500553, 438.727234, 0.999670267, -1.30875062e-08, 0.0256783087, 1.42019179e-08, 1, -4.32165699e-08, -0.0256783087, 4.35669989e-08, 0.999670267),
    ["Kohana Spot 2"] = Vector3.new(-897.885498, 5.7500596, 694.055359, -0.0598792434, -1.81639592e-08, 0.998205602, -7.78091647e-10, 1, 1.81499349e-08, -0.998205602, 3.10108939e-10, -0.0598792434),
    ["Lost Isle"] = Vector3.new(-3643, 1, -1061),
    ["Sacred Temple"] = Vector3.new(1498, -23, -644),
    ["Sysyphus Statue"] = Vector3.new(-3783.26807, -135.073914, -949.946289),
    ["Treasure Room"] = Vector3.new(-3600, -267, -1575),
    ["Tropical Grove"] = Vector3.new(-2091, 6, 3703),
    ["Weather Machine"] = Vector3.new(-1508, 6, 1895),
    ["Pirate Cave"] = Vector3.new(3398.86011, 4.19197035, 3480.54517, 0.617785096, -6.47339746e-08, -0.786346972, 3.20196716e-11, 1, -8.22972481e-08, 0.786346972, 5.0816837e-08, 0.617785096),
    ["Pirate Treasure room"] = Vector3.new(3299.81274, -305.034851, 3041.50952, -0.483591467, 2.84460047e-08, -0.875293851, -4.8970314e-08, 1, 5.95544378e-08, 0.875293851, 7.1663429e-08, -0.483591467),
    ["Crystal Depths"] = Vector3.new(5817.32715, -905.697144, 15416.3047, 0.0518231429, 1.04369903e-07, -0.998656273, -1.59683076e-08, 1, 1.03681693e-07, 0.998656273, 1.05737401e-08, 0.0518231429),
    ["Leviathan Den"] = Vector3.new(3474.05298, -287.774719, 3472.63403, -0.915228605, 0.097325258, -0.391004264, 3.60608101e-06, 0.970392585, 0.241532952, 0.402934879, 0.221056461, -0.88813144),
    ["Secret Passage"] = Vector3.new(3431.59546, -299.344971, 3359.79614, -0.947619379, 3.96371149e-08, -0.319401741, 3.15227737e-08, 1, 3.0574423e-08, 0.319401741, 1.89044869e-08, -0.947619379),
}

local SelectedIsland = nil

IslandSection:Dropdown({
    Name = "Select Island",
    Options = (function()
        local keys = {}
        for name in pairs(IslandLocations) do
            table.insert(keys, name)
        end
        table.sort(keys)
        return keys
    end)(),
    Default = nil,
    Callback = function(Value)
        SelectedIsland = Value
        Window:Notify({
            Title = "Island Selected",
            Description = "Ready to TP to: " .. (Value or "None"),
            Variant = "info",
            Lifetime = 3
        })
    end
})

IslandSection:Button({
    Name = "Teleport to Island",
    Callback = function()
        if SelectedIsland and IslandLocations[SelectedIsland] and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(IslandLocations[SelectedIsland])
            Window:Notify({
                Title = "Teleport Success",
                Description = "Teleported to " .. SelectedIsland,
                Variant = "success",
                Lifetime = 3
            })
        else
            Window:Notify({
                Title = "Teleport Failed",
                Description = "Select an island first or character not found",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})


-- EVENT TELEPORTER SECTION (after island TP)
local EventTeleporterSection = TeleportTab:Section({
    Name = "Event Teleporter",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- Auto Leviathan Hunt
_G.AutoLeviathanHunt = _G.AutoLeviathanHunt or false
local LeviathanThread = nil

EventTeleporterSection:Toggle({
    Name = "Auto Leviathan Hunt",
    Default = _G.AutoLeviathanHunt,
    Callback = function(state)
        _G.AutoLeviathanHunt = state
        
        if state then
            LeviathanThread = task.spawn(function()
                while _G.AutoLeviathanHunt do
                    pcall(function()
                        local zones = workspace:FindFirstChild("Zones")
                        if zones then
                            local leviathanDen = zones:FindFirstChild("Leviathan's Den")
                            if leviathanDen then
                                local character = game.Players.LocalPlayer.Character
                                if character and character:FindFirstChild("HumanoidRootPart") then
                                    local targetCFrame = CFrame.new(3474.05298, -287.774719, 3472.63403, -0.915228605, 0.097325258, -0.391004264, 3.60608101e-06, 0.970392585, 0.241532952, 0.402934879, 0.221056461, -0.88813144)
                                    character.HumanoidRootPart.CFrame = targetCFrame
                                    print("[Leviathan Hunt] ✓ Teleported to Leviathan's Den")
                                end
                            else
                                print("[Leviathan Hunt] Zone not found, waiting...")
                            end
                        end
                    end)
                    task.wait(30)
                end
            end)
            
            Window:Notify({
                Title = "Leviathan Hunt",
                Description = "Activated - Auto TP to Leviathan's Den when zone exists",
                Variant = "success",
                Lifetime = 4
            })
        else
            if LeviathanThread then
                task.cancel(LeviathanThread)
                LeviathanThread = nil
            end
            
            Window:Notify({
                Title = "Leviathan Hunt",
                Description = "Deactivated",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})

-- Auto Fish Event TP System
local Workspace = game:GetService("Workspace")
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

player.CharacterAdded:Connect(function(c)
    character = c
    hrp = c:WaitForChild("HumanoidRootPart")
end)

local megCheckRadius = 150
local autoEventTPEnabled = false
local selectedEvents = {}
local createdEventPlatform = nil

local eventData = {
    ["Worm Hunt"] = {
        TargetName = "Model",
        Locations = {
            Vector3.new(2190.85, -1.4, 97.575), 
            Vector3.new(-2450.679, -1.4, 139.731), 
            Vector3.new(-267.479, -1.4, 5188.531),
            Vector3.new(-327, -1.4, 2422)
        },
        PlatformY = 107,
        Priority = 1
    },
    ["Megalodon Hunt"] = {
        TargetName = "Megalodon Hunt",
        Locations = {
            Vector3.new(-1076.3, -1.4, 1676.2),
            Vector3.new(-1191.8, -1.4, 3597.3),
            Vector3.new(412.7, -1.4, 4134.4),
        },
        PlatformY = 107,
        Priority = 2
    },
    ["Ghost Shark Hunt"] = {
        TargetName = "Ghost Shark Hunt",
        Locations = {
            Vector3.new(489.559, -1.35, 25.406), 
            Vector3.new(-1358.216, -1.35, 4100.556), 
            Vector3.new(627.859, -1.35, 3798.081)
        },
        PlatformY = 107,
        Priority = 3
    },
    ["Shark Hunt"] = {
        TargetName = "Shark Hunt",
        Locations = {
            Vector3.new(1.65, -1.35, 2095.725),
            Vector3.new(1369.95, -1.35, 930.125),
            Vector3.new(-1585.5, -1.35, 1242.875),
            Vector3.new(-1896.8, -1.35, 2634.375)
        },
        PlatformY = 107,
        Priority = 4
    },
}

local eventNames = {}
for name in pairs(eventData) do
    table.insert(eventNames, name)
end

local function destroyEventPlatform()
    if createdEventPlatform and createdEventPlatform.Parent then
        createdEventPlatform:Destroy()
        createdEventPlatform = nil
    end
end

local function createAndTeleportToPlatform(targetPos, y)
    local desiredPos = Vector3.new(targetPos.X, y, targetPos.Z)

    if createdEventPlatform and createdEventPlatform.Parent then
        createdEventPlatform.Position = desiredPos
    else
        destroyEventPlatform()
        
        local platform = Instance.new("Part")
        platform.Size = Vector3.new(5, 1, 5)
        platform.Position = desiredPos
        platform.Anchored = true
        platform.Transparency = 1
        platform.CanCollide = true
        platform.Name = "EventPlatform"
        platform.Parent = Workspace
        createdEventPlatform = platform
    end

    hrp.CFrame = CFrame.new(createdEventPlatform.Position + Vector3.new(0, 3, 0))
end

local function runMultiEventTP()
    selectedEvents = type(selectedEvents) == "table" and selectedEvents or {}

    while autoEventTPEnabled do
        local sorted = {}

        for _, e in ipairs(selectedEvents) do
            local cfg = eventData[e]
            if cfg then
                table.insert(sorted, cfg)
            end
        end

        table.sort(sorted, function(a, b)
            return (a.Priority or 0) < (b.Priority or 0)
        end)

        for _, config in ipairs(sorted) do
            if not config.Locations then continue end

            local foundTarget, foundPos

            if config.TargetName == "Model" then
                local menuRings = Workspace:FindFirstChild("!!! MENU RINGS")
                if menuRings then
                    for _, props in ipairs(menuRings:GetChildren()) do
                        if props.Name == "Props" then
                            local model = props:FindFirstChild("Model")
                            if model and model.PrimaryPart then
                                for _, loc in ipairs(config.Locations) do
                                    if (model.PrimaryPart.Position - loc).Magnitude <= megCheckRadius then
                                        foundTarget = model
                                        foundPos = model.PrimaryPart.Position
                                        break
                                    end
                                end
                            end
                        end
                        if foundTarget then break end
                    end
                end
            else
                for _, d in ipairs(Workspace:GetDescendants()) do
                    if d.Name == config.TargetName then
                        local pos = d:IsA("BasePart") and d.Position or (d.PrimaryPart and d.PrimaryPart.Position)
                        if pos then
                            for _, loc in ipairs(config.Locations) do
                                if (pos - loc).Magnitude <= megCheckRadius then
                                    foundTarget = d
                                    foundPos = pos
                                    break
                                end
                            end
                        end
                    end
                    if foundTarget then break end
                end
            end

            if foundTarget and foundPos then
                createAndTeleportToPlatform(foundPos, config.PlatformY)
            end
        end

        task.wait(0.1)
    end

    destroyEventPlatform()
end

EventTeleporterSection:Dropdown({
    Name = "Select Fish Event",
    Options = eventNames,
    Callback = function(value)
        selectedEvents = { value }
        print("[EventTP] Selected Event:", value)
        Window:Notify({
            Title = "Event Selected",
            Description = "Auto TP to: " .. value,
            Variant = "info",
            Lifetime = 3
        })
    end
})

EventTeleporterSection:Toggle({
    Name = "Auto Fish Event TP",
    Default = false,
    Callback = function(state)
        autoEventTPEnabled = state
        if state then
            task.spawn(runMultiEventTP)
            Window:Notify({
                Title = "Auto Event TP",
                Description = "Activated - Auto TP to selected event",
                Variant = "success",
                Lifetime = 4
            })
        else
            destroyEventPlatform()
            Window:Notify({
                Title = "Auto Event TP",
                Description = "Deactivated",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})


-- TP TO PLAYER SECTION IN TELEPORT TAB
local PlayerTPSection = TeleportTab:Section({
    Name = "Tp To Player",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

local SelectedPlayer = nil

local PlayerDropdown = PlayerTPSection:Dropdown({
    Name = "Select Player",
    Options = (function()
        local players = {}
        for _, plr in pairs(game.Players:GetPlayers()) do
            if plr.Name ~= game.Players.LocalPlayer.Name then
                table.insert(players, plr.Name)
            end
        end
        table.sort(players)
        return players
    end)(),
    Callback = function(Value)
        SelectedPlayer = Value
        Window:Notify({
            Title = "Player Selected",
            Description = "Ready to TP to: " .. (Value or "None"),
            Variant = "info",
            Lifetime = 3
        })
    end
})

-- Refresh player list on join/leave
local function RefreshPlayerList()
    local list = {}
    for _, plr in pairs(game.Players:GetPlayers()) do
        if plr.Name ~= game.Players.LocalPlayer.Name then
            table.insert(list, plr.Name)
        end
    end
    table.sort(list)
    PlayerDropdown:Refresh(list)
end

game.Players.PlayerAdded:Connect(RefreshPlayerList)
game.Players.PlayerRemoving:Connect(RefreshPlayerList)

PlayerTPSection:Button({
    Name = "Teleport to Player",
    Callback = function()
        if SelectedPlayer then
            local target = game.Players:FindFirstChild(SelectedPlayer)
            if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = 
                        target.Character.HumanoidRootPart.CFrame + Vector3.new(0, 2, 0)
                    Window:Notify({
                        Title = "Teleport Success",
                        Description = "Teleported to " .. SelectedPlayer,
                        Variant = "success",
                        Lifetime = 3
                    })
                end
            else
                Window:Notify({
                    Title = "Failed",
                    Description = "Player or character not found",
                    Variant = "error",
                    Lifetime = 3
                })
            end
        else
            Window:Notify({
                Title = "Failed",
                Description = "Select a player first",
                Variant = "error",
                Lifetime = 3
            })
        end
    end
})



-- LUCK BOOSTERS SECTION IN SHOP TAB
local LuckBoosterSection = ShopTab:Section({
    Name = "Luck Boosters",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

ReplicatedStorage = game:GetService("ReplicatedStorage")
GiftingController = require(ReplicatedStorage:WaitForChild("Controllers"):WaitForChild("GiftingController"))

local luckBoosters = {
    "x2 Luck",
    "x4 Luck",
    "x8 Luck"
}

local selectedLuckBooster = luckBoosters[1]

LuckBoosterSection:Dropdown({
	Name = "Select Luck Booster",
	Options = luckBoosters,
	Default = selectedLuckBooster,
	Callback = function(value)
		selectedLuckBooster = value
	end
})

LuckBoosterSection:Button({
	Name = "Buy Luck Booster",
	Callback = function()
		local success, err = pcall(function()
			GiftingController:Open(selectedLuckBooster)
		end)
		if success then
			Window:Notify({Title = "Luck Booster", Description = "Purchased " .. selectedLuckBooster .. "!", Lifetime = 3})
		else
			Window:Notify({Title = "Purchase Error", Description = tostring(err), Lifetime = 5})
		end
	end
})



-- ROD SKINS SECTION IN SHOP TAB
local RodSkinsSection = ShopTab:Section({
    Name = "Rod Skins Gif",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

rodSkins = {
    "Frozen Krampus Scythe",
    "Gingerbread Katana",
    "Christmas Parasol", 
    "Aurelian Bow", 
    "Corruption Edge", 
    "Eclipe Katana", 
    "The Vanquisher", 
    "Black Hole Sword", 
    "Bam Hammer", 
    "Crescendo Scythe", 
    "Holy Trident", 
    "Continuum", 
    "Devine Blade", 
    "Soul Scythe", 
    "Cursed Katana"
}

local selectedRodSkin = rodSkins[1]

RodSkinsSection:Dropdown({
	Name = "Select Rod Skin",
	Options = rodSkins,
	Default = selectedRodSkin,
	Callback = function(value)
		selectedRodSkin = value
	end
})

RodSkinsSection:Button({
	Name = "Buy Rod Skin",
	Callback = function()
		local success, err = pcall(function()
			GiftingController:Open(selectedRodSkin)
		end)
		if success then
			Window:Notify({Title = "Rod Skin", Description = "Purchased " .. selectedRodSkin .. "!", Lifetime = 3})
		else
			Window:Notify({Title = "Purchase Error", Description = tostring(err), Lifetime = 5})
		end
	end
})


-- BUY ROD SECTION IN SHOP TAB
local BuyRodSection = ShopTab:Section({
    Name = "Buy Rod",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

ReplicatedStorage = game:GetService("ReplicatedStorage")
RFPurchaseFishingRod = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseFishingRod"]  

local rods = {  
    ["Luck Rod"] = 79,  
    ["Carbon Rod"] = 76,  
    ["Grass Rod"] = 85,
    ["Demascus Rod"] = 77,  
    ["Ice Rod"] = 78,  
    ["Lucky Rod"] = 4,  
    ["Midnight Rod"] = 80,  
    ["Steampunk Rod"] = 6,  
    ["Chrome Rod"] = 7,  
    ["Astral Rod"] = 5,  
    ["Ares Rod"] = 126,  
    ["Angler Rod"] = 168,
    ["Bamboo Rod"] = 258
}  

local rodNames = {  
    "Luck Rod (350 Coins)", "Carbon Rod (900 Coins)", "Grass Rod (1.5k Coins)", "Demascus Rod (3k Coins)",  
    "Ice Rod (5k Coins)", "Lucky Rod (15k Coins)", "Midnight Rod (50k Coins)", "Steampunk Rod (215k Coins)",  
    "Chrome Rod (437k Coins)", "Astral Rod (1M Coins)", "Ares Rod (3M Coins)", "Angler Rod (8M Coins)",
    "Bamboo Rod (12M Coins)"
}  

local rodKeyMap = {  
    ["Luck Rod (350 Coins)"]="Luck Rod",  
    ["Carbon Rod (900 Coins)"]="Carbon Rod",  
    ["Grass Rod (1.5k Coins)"]="Grass Rod",  
    ["Demascus Rod (3k Coins)"]="Demascus Rod",  
    ["Ice Rod (5k Coins)"]="Ice Rod",  
    ["Lucky Rod (15k Coins)"]="Lucky Rod",  
    ["Midnight Rod (50k Coins)"]="Midnight Rod",  
    ["Steampunk Rod (215k Coins)"]="Steampunk Rod",  
    ["Chrome Rod (437k Coins)"]="Chrome Rod",  
    ["Astral Rod (1M Coins)"]="Astral Rod",  
    ["Ares Rod (3M Coins)"]="Ares Rod",  
    ["Angler Rod (8M Coins)"]="Angler Rod",
    ["Bamboo Rod (12M Coins)"]="Bamboo Rod"
}  

local selectedRod = rodNames[1]  

BuyRodSection:Dropdown({
	Name = "Select Rod",
	Options = rodNames,  
	Default = selectedRod,  
	Callback = function(value)  
        selectedRod = value  
    end  
})  

BuyRodSection:Button({
	Name = "Buy Rod",
	Callback=function()  
        local key = rodKeyMap[selectedRod]  
        if key and rods[key] then  
            local success, err = pcall(function()  
                RFPurchaseFishingRod:InvokeServer(rods[key])  
            end)  
            if success then  
                Window:Notify({Title="Rod Purchase", Description="Purchased "..selectedRod, Lifetime=3})  
            else  
                Window:Notify({Title="Rod Purchase Error", Description=tostring(err), Lifetime=5})  
            end  
        end  
    end  
})


-- BUY BAITS SECTION IN SHOP TAB
local BuyBaitsSection = ShopTab:Section({
    Name = "Buy Baits",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

ReplicatedStorage = game:GetService("ReplicatedStorage")  
local RFPurchaseBait = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseBait"]  

local baits = {
    ["TopWater Bait"] = 10,
    ["Lucky Bait"] = 2,
    ["Midnight Bait"] = 3,
    ["Chroma Bait"] = 6,
    ["Dark Mater Bait"] = 8,
    ["Corrupt Bait"] = 15,
    ["Aether Bait"] = 16
}

local baitNames = {
    "TopWater Bait (100 Coins)",
    "Lucky Bait (1k Coins)",
    "Midnight Bait (3k Coins)",
    "Chroma Bait (290k Coins)",
    "Dark Mater Bait (630k Coins)",
    "Corrupt Bait (1.15M Coins)",
    "Aether Bait (3.7M Coins)"
}

local baitKeyMap = {
    ["TopWater Bait (100 Coins)"] = "TopWater Bait",
    ["Lucky Bait (1k Coins)"] = "Lucky Bait",
    ["Midnight Bait (3k Coins)"] = "Midnight Bait",
    ["Chroma Bait (290k Coins)"] = "Chroma Bait",
    ["Dark Mater Bait (630k Coins)"] = "Dark Mater Bait",
    ["Corrupt Bait (1.15M Coins)"] = "Corrupt Bait",
    ["Aether Bait (3.7M Coins)"] = "Aether Bait"
}

local selectedBait = baitNames[1]  

BuyBaitsSection:Dropdown({
	Name = "Select Bait",
	Options = baitNames,  
	Default = selectedBait,  
	Callback = function(value)  
        selectedBait = value  
    end  
})  

BuyBaitsSection:Button({
	Name = "Buy Bait",
	Callback = function()  
        local key = baitKeyMap[selectedBait]  
        if key and baits[key] then  
            local success, err = pcall(function()  
                RFPurchaseBait:InvokeServer(baits[key])  
            end)  
            if success then  
                Window:Notify({Title = "Bait Purchase", Description = "Purchased " .. selectedBait, Lifetime = 3})  
            else  
                Window:Notify({Title = "Bait Purchase Error", Description = tostring(err), Lifetime = 5})  
            end  
        end  
    end  
})


-- BUY WEATHER EVENTS SECTION IN SHOP TAB
local WeatherSection = ShopTab:Section({
    Name = "Buy Weather Events",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

ReplicatedStorage = game:GetService("ReplicatedStorage")
local RFPurchaseWeatherEvent = ReplicatedStorage.Packages._Index["sleitnick_net@0.2.0"].net["RF/PurchaseWeatherEvent"]

-- Data cuaca
local weathers = {
    ["Wind"] = "Wind",
    ["Cloudy"] = "Cloudy",
    ["Snow"] = "Snow",
    ["Storm"] = "Storm",
    ["Radiant"] = "Radiant",
    ["Shark Hunt"] = "Shark Hunt"
}

-- Nama tampilan
local weatherNames = {
    "Windy (10k Coins)",
    "Cloudy (20k Coins)",
    "Snow (15k Coins)",
    "Stormy (35k Coins)",
    "Radiant (50k Coins)",
    "Shark Hunt (300k Coins)"
}

-- Mapping nama → key internal
local weatherKeyMap = {
    ["Windy (10k Coins)"] = "Wind",
    ["Cloudy (20k Coins)"] = "Cloudy",
    ["Snow (15k Coins)"] = "Snow",
    ["Stormy (35k Coins)"] = "Storm",
    ["Radiant (50k Coins)"] = "Radiant",
    ["Shark Hunt (300k Coins)"] = "Shark Hunt"
}

local selectedWeather = weatherNames[1]  -- default single
local autoBuyRunning = false

WeatherSection:Dropdown({
	Name = "Select Weather Event",
	Options = weatherNames,
	Default = selectedWeather,
	Callback = function(value)
        selectedWeather = value
        print("Selected weather:", value)
        Window:Notify({
            Title = "Weather Selected",
            Description = "Ready to buy: " .. value,
            Variant = "info",
            Lifetime = 3
        })
    end
})

WeatherSection:Toggle({
	Name = "Auto Buy Selected Weather",
	SubText = "Continuously purchase the selected weather event while ON",
	Default = false,
	Callback = function(state)
        autoBuyRunning = state

        if state then
            if not selectedWeather then
                Window:Notify({
                    Title = "No Selection",
                    Description = "Please select a weather event first.",
                    Lifetime = 3
                })
                autoBuyRunning = false
                return
            end

            Window:Notify({
                Title = "Auto Buy Enabled",
                Description = "Auto-purchase started for " .. selectedWeather .. ". It will keep buying until turned off.",
                Lifetime = 4
            })

            -- Loop auto buy
            task.spawn(function()
                while autoBuyRunning do
                    local key = weatherKeyMap[selectedWeather]
                    if key and weathers[key] then
                        local success, err = pcall(function()
                            RFPurchaseWeatherEvent:InvokeServer(weathers[key])
                        end)
                        if success then
                            Window:Notify({
                                Title = "Weather Purchased",
                                Description = selectedWeather,
                                Lifetime = 2
                            })
                        else
                            warn("[Weather Buy] Error:", err)
                            Window:Notify({
                                Title = "Purchase Failed",
                                Description = tostring(err),
                                Variant = "error",
                                Lifetime = 3
                            })
                        end
                    else
                        Window:Notify({
                            Title = "Invalid Weather",
                            Description = "Invalid selection: " .. tostring(selectedWeather),
                            Lifetime = 3
                        })
                    end

                    task.wait(5)  -- delay aman 5 detik per cycle
                end
            end)
        else
            Window:Notify({
                Title = "Auto Buy Disabled",
                Description = "Weather auto-purchase stopped.",
                Lifetime = 3
            })
        end
    end
})


-- CAMERA TOOLS SECTION IN VIEW TAB
local CameraSection = ViewTab:Section({
    Name = "Camera Tools",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

local UnlimitedZoomModule = {}

-- Services
local Players = game:GetService("Players")

-- Variables
local Player = Players.LocalPlayer

-- Save original zoom settings
local originalMinZoom = Player.CameraMinZoomDistance
local originalMaxZoom = Player.CameraMaxZoomDistance

-- State
local unlimitedZoomActive = false

-- ============================================
-- MAIN FUNCTIONS
-- ============================================

function UnlimitedZoomModule.Enable()
    if unlimitedZoomActive then return false end
    
    unlimitedZoomActive = true
    
    -- Remove zoom limits (character can still move)
    Player.CameraMinZoomDistance = 0.5
    Player.CameraMaxZoomDistance = 9999
    
    print("Unlimited Zoom: ENABLED")
    print("Scroll to zoom in/out without limits")
    print("Character can move normally")
    
    return true
end

function UnlimitedZoomModule.Disable()
    if not unlimitedZoomActive then return false end
    
    unlimitedZoomActive = false
    
    -- Restore original zoom limits
    Player.CameraMinZoomDistance = originalMinZoom
    Player.CameraMaxZoomDistance = originalMaxZoom
    
    print("Unlimited Zoom: DISABLED")
    print("Zoom limits restored")
    
    return true
end

function UnlimitedZoomModule.IsActive()
    return unlimitedZoomActive
end

-- ============================================
-- CREATE TOGGLE IN VIEW TAB
-- ============================================

CameraSection:Toggle({
    Name = "Unlimited Zoom Camera",
    Icon = "rbxassetid://7733799682", -- Camera icon
    Default = false,
    Callback = function(state)
        if state then
            UnlimitedZoomModule.Enable()
            Window:Notify({
                Title = "Unlimited Zoom",
                Description = "Enabled - Zoom without limits (scroll to adjust)",
                Variant = "success",
                Lifetime = 4
            })
        else
            UnlimitedZoomModule.Disable()
            Window:Notify({
                Title = "Unlimited Zoom",
                Description = "Disabled - Zoom limits restored",
                Variant = "info",
                Lifetime = 3
            })
        end
    end
})


-- WALK ON WATER TOGGLE IN CAMERA TOOLS
local WalkOnWater = loadstring([[
-- ULTRA STABLE WALK ON WATER V3.2 (MODULE EDITION)
repeat task.wait() until game:IsLoaded()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

local WalkOnWater = {
	Enabled = false,
	Platform = nil,
	AlignPos = nil,
	Connection = nil
}

local PLATFORM_SIZE = 14
local OFFSET = 3
local LAST_WATER_Y = nil

local function GetCharacterReferences()
	local char = LocalPlayer.Character
	if not char then return end
	local humanoid = char:FindFirstChildOfClass("Humanoid")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not humanoid or not hrp then return end
	return char, humanoid, hrp
end

local function ForceSurfaceLift()
	local _, humanoid, hrp = GetCharacterReferences()
	if not humanoid or not hrp then return end
	if humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then return end
	
	for _ = 1, 60 do
		hrp.Velocity = Vector3.new(0, 80, 0)
		task.wait(0.03)
		if humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then break end
	end
	hrp.CFrame = hrp.CFrame + Vector3.new(0, 3, 0)
end

local function GetWaterHeight()
	local _, _, hrp = GetCharacterReferences()
	if not hrp then return LAST_WATER_Y end
	
	local origin = hrp.Position + Vector3.new(0, 5, 0)
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = { LocalPlayer.Character }
	params.IgnoreWater = false
	
	local result = Workspace:Raycast(origin, Vector3.new(0, -600, 0), params)
	if result then
		LAST_WATER_Y = result.Position.Y
		return LAST_WATER_Y
	end
	return LAST_WATER_Y
end

local function CreatePlatform()
	if WalkOnWater.Platform then
		WalkOnWater.Platform:Destroy()
	end
	
	local p = Instance.new("Part")
	p.Size = Vector3.new(PLATFORM_SIZE, 1, PLATFORM_SIZE)
	p.Anchored = true
	p.CanCollide = true
	p.Transparency = 1
	p.CanQuery = false
	p.CanTouch = false
	p.Name = "WaterLockPlatform"
	p.Parent = Workspace
	WalkOnWater.Platform = p
end

local function SetupAlign()
	local _, _, hrp = GetCharacterReferences()
	if not hrp then return false end
	
	if WalkOnWater.AlignPos then
		WalkOnWater.AlignPos:Destroy()
	end
	
	local att = hrp:FindFirstChild("RootAttachment")
	if not att then
		att = Instance.new("Attachment")
		att.Name = "RootAttachment"
		att.Parent = hrp
	end
	
	local ap = Instance.new("AlignPosition")
	ap.Attachment0 = att
	ap.MaxForce = math.huge
	ap.MaxVelocity = math.huge
	ap.Responsiveness = 200
	ap.RigidityEnabled = true
	ap.Parent = hrp
	WalkOnWater.AlignPos = ap
	return true
end

local function Cleanup()
	if WalkOnWater.Connection then
		WalkOnWater.Connection:Disconnect()
		WalkOnWater.Connection = nil
	end
	if WalkOnWater.AlignPos then
		WalkOnWater.AlignPos:Destroy()
		WalkOnWater.AlignPos = nil
	end
	if WalkOnWater.Platform then
		WalkOnWater.Platform:Destroy()
		WalkOnWater.Platform = nil
	end
end

function WalkOnWater.Start()
	if WalkOnWater.Enabled then return end
	local char, humanoid, hrp = GetCharacterReferences()
	if not char or not humanoid or not hrp then return end
	
	ForceSurfaceLift()
	WalkOnWater.Enabled = true
	LAST_WATER_Y = nil
	CreatePlatform()
	
	if not SetupAlign() then
		WalkOnWater.Enabled = false
		Cleanup()
		return
	end
	
	WalkOnWater.Connection = RunService.Heartbeat:Connect(function()
		if not WalkOnWater.Enabled then return end
		local _, _, currentHRP = GetCharacterReferences()
		if not currentHRP then return end
		
		local waterY = GetWaterHeight()
		if not waterY then return end
		
		if WalkOnWater.Platform then
			WalkOnWater.Platform.CFrame = CFrame.new(
				currentHRP.Position.X,
				waterY - 0.5,
				currentHRP.Position.Z
			)
		end
		
		if WalkOnWater.AlignPos then
			WalkOnWater.AlignPos.Position = Vector3.new(
				currentHRP.Position.X,
				waterY + OFFSET,
				currentHRP.Position.Z
			)
		end
	end)
end

function WalkOnWater.Stop()
	WalkOnWater.Enabled = false
	Cleanup()
end

LocalPlayer.CharacterAdded:Connect(function()
	if WalkOnWater.Enabled then
		task.wait(0.5)
		Cleanup()
		WalkOnWater.Enabled = false
		WalkOnWater.Start()
	end
end)

return WalkOnWater
]])()

-- Toggle Walk on Water
CameraSection:Toggle({
    Name = "Walk on Water",
    Default = false,
    Callback = function(value)
        if value then
            WalkOnWater.Start()
        else
            WalkOnWater.Stop()
        end
    end
})



-- ANTI-AFK & AUTO RECONNECT IN MOVEMENT & SAFETY
CameraSection:Toggle({
	Name = "Anti-AFK",
	Default = false,
	Callback = function(state)
        _G.AntiAFK = state
        local VirtualUser = game:GetService("VirtualUser")

        if state then
            task.spawn(function()
                while _G.AntiAFK do
                    task.wait(60)
                    pcall(function()
                        VirtualUser:CaptureController()
                        VirtualUser:ClickButton2(Vector2.new())
                    end)
                end
            end)
        end
    end
})

CameraSection:Toggle({
	Name = "Auto Reconnect",
	Default = false,
	Callback = function(state)
        _G.AutoReconnect = state
        if state then
            task.spawn(function()
                while _G.AutoReconnect do
                    task.wait(2)

                    local reconnectUI = game:GetService("CoreGui"):FindFirstChild("RobloxPromptGui")
                    if reconnectUI then
                        local prompt = reconnectUI:FindFirstChild("promptOverlay")
                        if prompt then
                            local button = prompt:FindFirstChild("ButtonPrimary")
                            if button and button.Visible then
                                firesignal(button.MouseButton1Click)
                            end
                        end
                    end
                end
            end)
        end
    end
})


-- HIDE STATS IDENTIFIER SECTION IN VIEW TAB
local HideStatsSection = ViewTab:Section({
    Name = "Hide Stats",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

-- Paste your code exactly here (no changes to logic)
local HideStatsModule = {}

-- Settings
local HideStatsEnabled = false
local FakeName = "discord.gg/noxius"
local FakeLevel = "-999"
local ScriptName = "NOXIUS COMMUNITY"

-- Variable untuk menyimpan original text
local OriginalTexts = {}
local ActiveGradientThreads = {}

-- Warna untuk efek shimmer/berkilau Orange-Putih
local ShimmerColors = {
    Color3.fromRGB(80, 0, 120),     -- Deep Purple
    Color3.fromRGB(120, 0, 190),    -- Purple
    Color3.fromRGB(170, 90, 255),   -- Bright Purple
    Color3.fromRGB(255, 255, 255),  -- White Shine (kilau)
    Color3.fromRGB(170, 90, 255),   -- Bright Purple
    Color3.fromRGB(120, 0, 190),    -- Purple
    Color3.fromRGB(80, 0, 120),     -- Deep Purple
}


-- Fungsi untuk membuat UIGradient shimmer effect yang bergerak
local function createMovingGradient(label)
    if not label or not label:IsA("TextLabel") then return end
    
    -- Hapus gradient lama jika ada
    local oldGradient = label:FindFirstChild("ShimmerGradient")
    if oldGradient then oldGradient:Destroy() end
    
    -- Buat UIGradient baru
    local gradient = Instance.new("UIGradient")
    gradient.Name = "ShimmerGradient"
    gradient.Parent = label
    
    -- Setup ColorSequence untuk efek shimmer/berkilau
    local colorKeypoints = {}
    
    local basePattern = {
        {0.00, Color3.fromRGB(255, 140, 0)},
        {0.10, Color3.fromRGB(255, 160, 30)},
        {0.20, Color3.fromRGB(255, 200, 100)},
        {0.30, Color3.fromRGB(255, 255, 255)},
        {0.40, Color3.fromRGB(255, 200, 100)},
        {0.50, Color3.fromRGB(255, 160, 30)},
        {0.60, Color3.fromRGB(255, 140, 0)},
        {0.70, Color3.fromRGB(255, 160, 30)},
        {0.80, Color3.fromRGB(255, 200, 100)},
        {0.90, Color3.fromRGB(255, 255, 255)},
        {1.00, Color3.fromRGB(255, 140, 0)},
    }
    
    for _, data in ipairs(basePattern) do
        table.insert(colorKeypoints, ColorSequenceKeypoint.new(data[1], data[2]))
    end
    
    gradient.Color = ColorSequence.new(colorKeypoints)
    
    -- Mulai animasi shimmer dari kiri ke kanan
    local threadId = tostring(label)
    ActiveGradientThreads[threadId] = true
    
    spawn(function()
        local offset = 0
        while label and label.Parent and ActiveGradientThreads[threadId] do
            offset = offset + 0.015
            if offset >= 1 then
                offset = 0
            end
            
            gradient.Offset = Vector2.new(offset, 0)
            wait(0.02)
        end
    end)
    
    return gradient
end

-- Fungsi untuk membuat clone TextLabel untuk script name
local function createScriptNameLabel(nameLabel, billboard)
    if not nameLabel or not billboard then return end
    
    local existingFrame = billboard:FindFirstChild("LynxFrame")
    if existingFrame then 
        return existingFrame
    end
    
    local nameFrame = nameLabel.Parent
    if not nameFrame or not nameFrame:IsA("Frame") then return end
    
    local originalNamePos = nameFrame.Position
    nameFrame.Position = UDim2.new(
        originalNamePos.X.Scale,
        originalNamePos.X.Offset,
        originalNamePos.Y.Scale + 0.25,
        originalNamePos.Y.Offset
    )
    
    local lynxFrame = Instance.new("Frame")
    lynxFrame.Name = "LynxFrame"
    lynxFrame.Size = nameFrame.Size
    lynxFrame.Position = originalNamePos
    lynxFrame.BackgroundTransparency = 1
    lynxFrame.Parent = billboard
    
    local scriptLabel = nameLabel:Clone()
    scriptLabel.Name = "LynxLabel"
    scriptLabel.Text = ScriptName
    scriptLabel.TextScaled = true
    scriptLabel.Font = Enum.Font.GothamBold
    scriptLabel.TextStrokeTransparency = 0.5
    scriptLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    scriptLabel.Parent = lynxFrame
    
    createMovingGradient(scriptLabel)
    
    return lynxFrame
end

-- Fungsi untuk menghapus semua script name labels
local function removeAllScriptNames()
    local character = LocalPlayer.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local overhead = hrp:FindFirstChild("Overhead")
    if not overhead then return end
    
    local lynxFrame = overhead:FindFirstChild("LynxFrame")
    if lynxFrame then
        for threadId, _ in pairs(ActiveGradientThreads) do
            ActiveGradientThreads[threadId] = nil
        end
        
        local nameLabel = overhead:FindFirstChild("Header", true)
        if nameLabel then
            local nameFrame = nameLabel.Parent
            if nameFrame and nameFrame:IsA("Frame") then
                local currentPos = nameFrame.Position
                nameFrame.Position = UDim2.new(
                    currentPos.X.Scale,
                    currentPos.X.Offset,
                    currentPos.Y.Scale - 0.25,
                    currentPos.Y.Offset
                )
            end
        end
        
        lynxFrame:Destroy()
    end
end

-- Fungsi untuk mengubah nama dan level di overhead display
local function updateStats()
    if not HideStatsEnabled then 
        removeAllScriptNames()
        return 
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local overhead = hrp:FindFirstChild("Overhead")
    if not overhead or not overhead:IsA("BillboardGui") then return end
    
    for _, obj in pairs(overhead:GetDescendants()) do
        if obj:IsA("TextLabel") then
            local fullPath = obj:GetFullName()
            
            if not OriginalTexts[fullPath] then
                OriginalTexts[fullPath] = obj.Text
            end
            
            local originalText = OriginalTexts[fullPath]
            
            if originalText and originalText ~= "" then
                if obj.Name == "Header" then
                    if not overhead:FindFirstChild("LynxFrame") then
                        createScriptNameLabel(obj, overhead)
                    end
                    obj.Text = FakeName
                elseif string.find(string.lower(originalText), "lvl") then
                    obj.Text = string.gsub(originalText, "%d+", FakeLevel)
                end
            end
        end
    end
end

-- Auto-update loop
local updateLoop
local function startUpdateLoop()
    if updateLoop then return end
    updateLoop = true
    spawn(function()
        while updateLoop and wait(0.2) do
            if HideStatsEnabled then
                updateStats()
            end
        end
    end)
end

-- PUBLIC FUNCTIONS
function HideStatsModule.Enable()
    HideStatsEnabled = true
    startUpdateLoop()
    updateStats()
end

function HideStatsModule.Disable()
    HideStatsEnabled = false
    
    -- Restore original texts
    for path, originalText in pairs(OriginalTexts) do
        local obj = game
        for part in string.gmatch(path, "[^.]+") do
            obj = obj:FindFirstChild(part)
            if not obj then break end
        end
        if obj and obj:IsA("TextLabel") then
            obj.Text = originalText
        end
    end
    
    removeAllScriptNames()
end

function HideStatsModule.SetFakeName(name)
    FakeName = name or "Guest"
    if HideStatsEnabled then
        updateStats()
    end
end

function HideStatsModule.SetFakeLevel(level)
    FakeLevel = tostring(level or "1")
    if HideStatsEnabled then
        updateStats()
    end
end

function HideStatsModule.IsEnabled()
    return HideStatsEnabled
end

function HideStatsModule.GetSettings()
    return {
        enabled = HideStatsEnabled,
        fakeName = FakeName,
        fakeLevel = FakeLevel
    }
end

-- Character respawn handler
LocalPlayer.CharacterAdded:Connect(function(character)
    OriginalTexts = {}
    ActiveGradientThreads = {}
    wait(1)
    if HideStatsEnabled then
        updateStats()
    end
end)

-- Monitor untuk GUI baru
if LocalPlayer.Character then
    LocalPlayer.Character.DescendantAdded:Connect(function(descendant)
        if HideStatsEnabled and descendant:IsA("BillboardGui") then
            wait(0.1)
            updateStats()
        end
    end)
end

-- Initial setup
if LocalPlayer.Character then
    wait(1)
    if HideStatsEnabled then
        updateStats()
    end
end

-- Toggle Hide Stats
CameraSection:Toggle({
    Name = "Hide Stats Identifier",
    Default = false,
    Callback = function(state)
        if state then
            HideStatsModule.Enable()
        else
            HideStatsModule.Disable()
        end
    end
})

-- FISH WEBHOOK SECTION IN WEB TAB
local FishWebhookSection = WebTab:Section({
    Name = "Fish Webhook",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

_G.WebhookURL = _G.WebhookURL or ""
_G.WebhookRarities = _G.WebhookRarities or {}
_G.WebhookVariants = _G.WebhookVariants or {}
_G.WebhookCrystalized = _G.WebhookCrystalized or false
_G.DetectNewFishActive = _G.DetectNewFishActive or false

local httpRequest = syn and syn.request or http and http.request or http_request or request
if not httpRequest then return end

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local rarityList = { "Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythic", "SECRET" }
local variantList = {
    "Galaxy", "Corrupt", "Gemstone", "Fairy Dust", "Midnight",
    "Color Burn", "Holographic", "Lightning", "Radioactive",
    "Ghost", "Gold", "Frozen", "1x1x1x1", "Stone", "Sandy",
    "Noob", "Moon Fragment", "Festive", "Albino", "Arctic Frost", "Disco", "Big", "Giant", "Sparkling",
    "Crystalized"
}

local tierToRarity = {
    [1] = "Common", [2] = "Uncommon", [3] = "Rare", [4] = "Epic",
    [5] = "Legendary", [6] = "Mythic", [7] = "SECRET"
}

fishDB = fishDB or {}

function buildFishDatabase()
    table.clear(fishDB)
    local itemsContainer = ReplicatedStorage:WaitForChild("Items")
    
    for _, itemModule in ipairs(itemsContainer:GetChildren()) do
        if itemModule:IsA("ModuleScript") then
            local success, itemData = pcall(require, itemModule)
            if success and itemData and itemData.Data and itemData.Data.Type == "Fish" then
                local data = itemData.Data
                if data.Id and data.Name then
                    fishDB[data.Id] = {
                        Name = data.Name,
                        Tier = data.Tier,
                        Icon = data.Icon,
                        SellPrice = itemData.SellPrice or 0
                    }
                end
            end
        end
    end
end

buildFishDatabase()

function getPlayerCoins()
    local DataService = nil
    pcall(function()
        local Replion = require(ReplicatedStorage.Packages.Replion)
        DataService = Replion.Client:WaitReplion("Data")
    end)
    if not DataService then return "N/A" end
    local success, coins = pcall(function() return DataService:Get("Coins") end)
    if success and coins then return string.format("%d", coins):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "") end
    return "N/A"
end

function getThumbnailURL(assetString)
    local assetId = assetString:match("rbxassetid://(%d+)")
    if not assetId then return nil end
    local api = string.format("https://thumbnails.roblox.com/v1/assets?assetIds=%s&type=Asset&size=420x420&format=Png", assetId)
    local success, response = pcall(function() return HttpService:JSONDecode(game:HttpGet(api)) end)
    return success and response and response.data and response.data[1] and response.data[1].imageUrl
end

function sendTestWebhook()
    if not httpRequest or not _G.WebhookURL or not _G.WebhookURL:match("discord.com/api/webhooks") then
        Window:Notify({ Title = "Error", Description = "Webhook URL Empty" })
        return
    end

    local payload = {
        username = "Noxius Community Webhook",
        embeds = {{
            title = "Test Webhook Connected",
            description = "Webhook connection successful!",
            color = 0x00FF00
        }}
    }

    pcall(function()
        httpRequest({
            Url = _G.WebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

function sendNewFishWebhook(newlyCaughtFish)
    if not httpRequest or not _G.WebhookURL or not _G.WebhookURL:match("discord.com/api/webhooks") then return end

    local newFishDetails = fishDB[newlyCaughtFish.Id]
    if not newFishDetails then return end

    local newFishRarity = tierToRarity[newFishDetails.Tier] or "Unknown"
    local mutation   = (newlyCaughtFish.Metadata and newlyCaughtFish.Metadata.VariantId and tostring(newlyCaughtFish.Metadata.VariantId)) or "None"

    local isCrystalized = mutation == "Crystalized"
    local forceAnnounce = _G.WebhookCrystalized and isCrystalized

    if not forceAnnounce then
        if #_G.WebhookRarities > 0 and not table.find(_G.WebhookRarities, newFishRarity) then return end
        if _G.WebhookVariants and #_G.WebhookVariants > 0 and not table.find(_G.WebhookVariants, mutation) then return end
    end

    local fishWeight = (newlyCaughtFish.Metadata and newlyCaughtFish.Metadata.Weight and string.format("%.2f Kg", newlyCaughtFish.Metadata.Weight)) or "N/A"
    local sellPrice  = (newFishDetails.SellPrice and ("$"..string.format("%d", newFishDetails.SellPrice):reverse():gsub("(%d%d%d)", "%1,"):reverse():gsub("^,", "").." Coins")) or "N/A"
    local currentCoins = getPlayerCoins()

    local totalFishInInventory = #getInventoryFish()
    local backpackInfo = string.format("%d/4500", totalFishInInventory)

    local playerName = game.Players.LocalPlayer.Name

    local payload = {
        content = nil,
        embeds = {{
            title = "Noxius Community Fish caught!",
            description = string.format("Congrats! **%s** You obtained new **%s** here for full detail fish :", playerName, newFishRarity),
            url = "https://discord.gg/noxius",
            color = 8900346,
            fields = {
                { name = "Name Fish :",        value = "```\n"..newFishDetails.Name.."```" },
                { name = "Rarity :",           value = "```"..newFishRarity.."```" },
                { name = "Weight :",           value = "```"..fishWeight.."```" },
                { name = "Mutation :",         value = "```"..mutation.."```" },
                { name = "Sell Price :",       value = "```"..sellPrice.."```" },
                { name = "Backpack Counter :", value = "```"..backpackInfo.."```" },
                { name = "Current Coin :",     value = "```"..currentCoins.."```" },
            },
            footer = {
                text = "Noxius Community Webhook"
            },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%S.000Z"),
            thumbnail = {
                url = getThumbnailURL(newFishDetails.Icon)
            }
        }},
        username = "Noxius Community Webhook"
    }

    pcall(function()
        httpRequest({
            Url = _G.WebhookURL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

FishWebhookSection:Input({
	Name = "URL Webhook",
	Default = _G.WebhookURL or "",
	Callback = function(text)
        _G.WebhookURL = text
    end
})

FishWebhookSection:Dropdown({
	Name = "Rarity Filter",
	Options = rarityList,
	Default = _G.WebhookRarities[1] or "Common",
	Callback = function(selected)
        _G.WebhookRarities = { selected }
    end
})

FishWebhookSection:Dropdown({
	Name = "Variant Filter",
	Options = variantList,
	Default = _G.WebhookVariants[1] or "None",
	Callback = function(selected)
        _G.WebhookVariants = { selected }
    end
})

FishWebhookSection:Toggle({
    Name = "Always Announce Crystalized",
    Default = _G.WebhookCrystalized or false,
    Callback = function(state)
        _G.WebhookCrystalized = state
    end
})

FishWebhookSection:Toggle({
	Name = "Send Webhook",
	Default = _G.DetectNewFishActive or false,
	Callback = function(state)
        _G.DetectNewFishActive = state
    end
})

FishWebhookSection:Button({
	Name = "Test Webhook",
	Callback = sendTestWebhook
})

-- WHATSAPP NOTIFICATION SECTION IN WEB TAB
local WASection = WebTab:Section({
    Name = "WhatsApp Notification",
    Side = "Left",
    Collapsible = true,
    DefaultCollapsed = false
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")  

-- Fonnte API Token (default lu)
_G.FonnteToken        = _G.FonnteToken or "eJ2K4skattShv2iwYXCU"        -- Token API Fonnte
_G.WA_TargetPhone     = _G.WA_TargetPhone or ""     -- Nomor tujuan WA (62xxxx)
_G.WA_NumberID        = _G.WA_NumberID or ""        -- WhatsApp Business Number ID
_G.WA_AccessToken     = _G.WA_AccessToken or ""     -- WhatsApp Business Access Token

function sendFonnteMessage(number, message, imageURL)
    local payload = {
        target = number,
        message = message
    }
    if imageURL then
        payload.image = imageURL
    end

    pcall(function()
        httpRequest({
            Url = "https://api.fonnte.com/send",
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json",
                ["Authorization"] = _G.FonnteToken
            },
            Body = HttpService:JSONEncode(payload)
        })
    end)
end

function sendNewFishWA(fish)
    local info = fishDB[fish.Id]
    if not info then return end

    local rarity = tierToRarity[info.Tier] or "Unknown"
    local variant  = (fish.Metadata and fish.Metadata.VariantId and tostring(fish.Metadata.VariantId)) or "None"

    local isCrystalized = variant == "Crystalized"
    local forceAnnounce = _G.WebhookCrystalized and isCrystalized

    if not forceAnnounce then
        if #_G.WebhookRarities > 0 and not table.find(_G.WebhookRarities, rarity) then
            return
        end
        if _G.WebhookVariants and #_G.WebhookVariants > 0 and not table.find(_G.WebhookVariants, variant) then
            return
        end
    end

    local weight   = (fish.Metadata and fish.Metadata.Weight and string.format("%.2f Kg", fish.Metadata.Weight)) or "N/A"
    local iconURL  = getThumbnailURL(info.Icon)
    local playerName = game.Players.LocalPlayer.Name

    local msg = "🐟 New Fish Caught 🐟\n" .. "*" .. playerName .. "*" .. " Has Caught An *".. rarity .."* Fish!!!\n\n" ..
                "• Name: " .. info.Name .. "\n" ..
                "• Rarity: " .. rarity .. "\n" ..
                "• Weight: " .. weight .. "\n" ..
                "• Variant: " .. variant .. "\n" ..
                "• Sell Price: " .. tostring(info.SellPrice)

    sendFonnteMessage(_G.WA_TargetPhone, msg, iconURL)
end

WASection:Input({
	Name = "Target Phone (62...)",
	Default = _G.WA_TargetPhone or "",
	Callback = function(t)
        _G.WA_TargetPhone = t
    end
})

WASection:Dropdown({
	Name = "Rarity Filter",
	Options = rarityList,
	Default = _G.WebhookRarities[1] or "Common",
	Callback = function(selected)
        _G.WebhookRarities = { selected }
    end
})

WASection:Dropdown({
	Name = "Variant Filter",
	Options = variantList,
	Default = _G.WebhookVariants[1] or "None",
	Callback = function(selected)
        _G.WebhookVariants = { selected }
    end
})

WASection:Toggle({
	Name = "Send WA Notification",
	Default = _G.DetectNewFishActive or false,
	Callback = function(state)
        _G.DetectNewFishActive = state
    end
})

WASection:Button({
	Name = "Test Whatsapp",
	Callback = function()
        sendFonnteMessage(_G.WA_TargetPhone, "Test berhasil! WhatsApp aktif.", nil)
    end
})


local function createGui(parent)
    local screenGui = Instance.new("ScreenGui", parent)
    screenGui.Name = "Ajomok UI"
    screenGui.ResetOnSpawn = false
    screenGui.DisplayOrder = 999999
    screenGui.IgnoreGuiInset = true
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    local UserInputService = game:GetService("UserInputService")

    local Frame1 = Instance.new("Frame", screenGui)
    Frame1.AnchorPoint = Vector2.new(0, 0.5)
    Frame1.Name = "main"
    Frame1.Position = UDim2.new(0, 5, 0.5, 0)
    Frame1.Size = UDim2.new(0, 55, 0, 55)
    Frame1.BackgroundColor3 = Color3.new(25, 15, 40)
    Frame1.BorderSizePixel = 0
    Frame1.Active = true
    Frame1.Draggable = false
    
    local dragging = false
    local dragInput
    local dragStart
    local startPos
    
    local function update(input)
        local delta = input.Position - dragStart
        Frame1.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
    
    Frame1.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = Frame1.Position
            
            local connection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    connection:Disconnect()
                end
            end)
        end
    end)
    
    Frame1.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            update(input)
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            update(input)
        end
    end)
    
    local UIGradient2 = Instance.new("UIGradient", Frame1)
    UIGradient2.Rotation = 50
    UIGradient2.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.new(0.66, 0, 1)),
        ColorSequenceKeypoint.new(0.5, Color3.new(0.12, 0.06, 0.2)),
        ColorSequenceKeypoint.new(1, Color3.new(0.66, 0, 1))
    }
    
    local UICorner3 = Instance.new("UICorner", Frame1)
    UICorner3.CornerRadius = UDim.new(0, 15)
    
    local UIStroke4 = Instance.new("UIStroke", Frame1)
    UIStroke4.Color = Color3.new(0.8, 0, 1)
    UIStroke4.Thickness = 2
    
    local UIGradient5 = Instance.new("UIGradient", UIStroke4)
    UIGradient5.Rotation = 90
    UIGradient5.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.new(0.9, 0, 1)),
        ColorSequenceKeypoint.new(1, Color3.new(0.35, 0, 0.5))
    }
    
    local ImageLabel6 = Instance.new("ImageLabel", Frame1)
    ImageLabel6.Size = UDim2.new(0, 35, 0, 35)
    ImageLabel6.Image = "rbxassetid://77194008928196"
    ImageLabel6.BackgroundTransparency = 1
    ImageLabel6.Position = UDim2.new(0.181818187, 0, 0.181818187, 0)
    ImageLabel6.BorderColor3 = Color3.new(0, 0, 0)
    ImageLabel6.Name = "imege"
    ImageLabel6.BorderSizePixel = 0
    ImageLabel6.BackgroundColor3 = Color3.new(1, 1, 1)
    
    local TextButton7 = Instance.new("TextButton", Frame1)
    TextButton7.TextColor3 = Color3.new(0, 0, 0)
    TextButton7.BorderColor3 = Color3.new(0, 0, 0)
    TextButton7.TextTransparency = 1
    TextButton7.Font = Enum.Font.SourceSans
    TextButton7.Name = "togl"
    TextButton7.TextSize = 14
    TextButton7.Size = UDim2.new(0, 55, 0, 50)
    TextButton7.BackgroundTransparency = 1
    TextButton7.BorderSizePixel = 0
    TextButton7.BackgroundColor3 = Color3.new(1, 1, 1)
    TextButton7.ZIndex = 9999999
    
    TextButton7.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = Frame1.Position
            
            local connection = input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                    connection:Disconnect()
                end
            end)
        end
    end)
    
    TextButton7.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            update(input)
        end
    end)
    
    return screenGui
end

local interface = {}

function interface:is_already_executed()
    if game.CoreGui:FindFirstChild("Ajomok UI") then
        game.CoreGui:FindFirstChild("Ajomok UI"):Destroy()
    end
end

function interface:toggle_position()
    local edan = game.CoreGui:FindFirstChild("Ajomok UI")
    return edan
end

function interface:initial_interface(callback)
    interface:is_already_executed()  -- destroy kalau sudah ada
    
    local ui = createGui(game.CoreGui)
    if callback then
        ui.main.togl.MouseButton1Click:Connect(function()
            pcall(callback)
        end)
    end
    
    return ui
end

interface:initial_interface(function()
    if Window and Window.SetState then
        Window:SetState(not Window:GetState())
    else
        local winFrame = game.CoreGui:FindFirstChildWhichIsA("ScreenGui", true):FindFirstChild("Window", true) -- adjust name kalau perlu
        if winFrame then
            winFrame.Visible = not winFrame.Visible
        end
    end
end)

MainTab:Select()